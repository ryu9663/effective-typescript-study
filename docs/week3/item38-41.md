# 아이템 38: 타입은 가능한 한 좁은 범위에서만 사용하기

## 1️⃣ TypeScript는 점진적 타입 시스템이고, any는 ‘탈출구’다

- TypeScript는 선택적이고 점진적이며 정적이면서 동적이다.
- **전체를 한 번에 타입화하지 않아도 되는 점진적(gradual) 타입 시스템**

이 덕분에 JavaScript → TypeScript 마이그레이션이 가능하다.

이 과정에서 `any`는:

- 타입 체크를 일시적으로 비활성화하는 **탈출구**
- 하지만 동시에 **가장 강력하고 위험한 타입**이다

그래서 문제는 “any를 쓰느냐 마느냐”가 아니라  
👉 **어디까지 퍼지게 하느냐**다.

---

## 2️⃣ 가장 위험한 패턴: 함수 반환 타입이 any

- `any`가 **반환값을 통해 함수 밖으로 전파**
- 호출 지점에서는 더 이상 타입 체커가 보호해주지 않는다
- any는 전염(contagious)된다

👉 **함수 반환 타입에 any를 두지 말라**는 이 단원의 핵심 경고다.

---

## 3️⃣ 차선책 as any: any를 사용 지점에만 가둬라

같은 오류를 제거하더라도, 아래 방식이 훨씬 낫다.

```ts
function f2() {
  const x = expressionReturningFoo();
  processBar(x as any); // ⭕ 여기서만 any
  return x; // Foo 타입 유지
}
```

- x: any 대신 x as any 사용
- 함수의 반환 타입은 안전하게 유지됨
- 영향 범위가 국소적이다

👉 **any 를 퍼지지않고 딱 필요한 위치에서만 가둬라**

---

## 4️⃣ 객체에서도 동일: 객체 전체를 any로 만들지 마라

❌ 나쁜 예:

```ts
const config = {
  a: 1,
  b: 2,
  c: {
    key: value,
  },
} as any;
```

- 객체 전체가 타입 체크 대상에서 탈락
- a, b 같은 정상 필드까지 보호를 잃음

⭕ 좋은 예:

```ts
const config: Config = {
  a: 1,
  b: 2, // 여전히 체크됨
  c: {
    key: value as any, // 문제 지점만 any
  },
};
```

👉 **any는 객체 전체가 아니라 “문제 속성 하나”에만 적용**

---

## 5️⃣ any vs @ts-ignore

```ts
// @ts-ignore
processBar(x);
```

- 다음 줄의 타입 오류만 무시
- any처럼 타입 정보를 바꾸지 않음
- 전파되지 않음

👉 **강제로 막아야 할 때는 any보다 @ts-ignore가 낫다.**  
(단, 근본 해결은 아님)

---

# 아이템 39: any를 구체적으로 변형해서 사용하기

## 1️⃣ any 가 위험한 이유

**any는 너무 넓은 타입이다**

- any 는 자바스크립트에서 표현할 수 있는 모든 값을 아우르는 매우 큰 범위의 타입
  👉🏻 `any`는 자바스크립트에서 표현 가능한 **모든 값**을 포함한다.

즉, `any`를 사용하면 타입스크립트의 타입 검사가 사실상 비활성화된다.  
일반적인 상황에서는 `any`보다 더 구체적인 타입이 존재할 가능성이 높다.
👉🏻 찾아서 타입 안정성을 높여야 한다.

---

## 2️⃣ any[]로 형태를 구체화하기

(1) any를 그대로 쓰면 생기는 문제

```ts
function getLengthBad(array: any) {
  return array.length;
}
```

문제점:

- `array.length`에 대한 타입 체크가 되지 않는다.
- 반환 타입이 `any`로 추론된다.
- 배열이 아닌 값도 인자로 전달 가능하다.

```ts
getLengthBad(/123/); // 오류 없음, undefined 반환
```

(2) 해결책: any[]로 형태를 구체화하기

```ts
function getLength(array: any[]) {
  return array.length;
}
```

개선점:

- `array.length`가 안전하게 타입 체크된다.
- 반환 타입이 `number`로 추론된다.
- 호출 시 배열 여부가 검사된다.

👉 요소 타입을 몰라도 **배열이라는 구조 정보만으로도 타입 안정성이 크게 향상된다.**

---

## 3️⃣ object 타입과의 차이

```ts
function hasTwelveLetterKey(o: object) {
  for (const key in o) {
    console.log(o[key]);
    // ❌ object에는 인덱스 시그니처가 없음
  }
}
```

- `object`는 **속성(o[key]) 접근이 불가능**
- `{ [key: string]: any }`는 속성 접근 가능
- 둘은 목적이 다르다

---

# 아이템 40: 함수 안으로 타입 단언문 감추기

## 1️⃣ 타입 단언은 위험한데, 왜 쓰게 되나? (as any, as T)

함수를 작성하다 보면,

- 외부에 드러난 타입 정의는 단순하지만
- 내부 구현 로직은 복잡해서 안전한 타입으로 표현하기 어려운 경우가 많다.

이상적으로는 모든 코드를 안전한 타입으로 작성하는 것이 좋지만,
불필요한 예외 상황까지 고려하며 타입을 과도하게 복잡하게 만들 필요는 없다.

👉 **함수 내부에는 타입 단언을 허용하되,  
함수 외부에는 정확한 타입 시그니처만 노출하는 것이 바람직하다.**

---

## 2️⃣ 타입 단언으로 내부 오류를 국소화하기

단언이 필요하면, 함수 내부에서만 단언하고 끝내서
호출부는 어떤 위험도 모르고 안전하게 쓰게 만들어라.

따라서 **함수 전체를 단언하여 오류를 제거**할 수 있다.

여기서 포인트는:
• 내부 구현에는 any, unknown이 보여도 된다
• 대신 함수 시그니처(겉으로 보이는 타입) 는 정확해야 한다
• 호출하는 쪽은 any를 마주칠 일이 없어야 한다

👉🏻 단언을 국소화해서 리스크를 통제하라

---

## 3️⃣ 중요한 설계 포인트

- 타입 단언은 **국소적으로 사용**해야 한다.
- 호출부까지 타입 단언이 전파되면 설계가 나쁘다.
- 이 패턴은 **라이브러리 코드에서 특히 중요**하다.

---

# 아이템 41: any의 진화를 이해하기

## 1️⃣ 타입은 보통 좁혀지지만(narrowing), 확장되지는 않는다

하지만 `any`와 는 예외다.  
특히 **암시적 any**는 코드 흐름에 따라 타입이 점점 구체화될 수 있다.

---

## 대표적인 예시: 배열에서 발생하는 any의 진화

```ts
function range(start: number, limit: number) {
  const out = []; // 이 시점에서 out 의 타입은 any[]
  for (let i = start; i < limit; i++) {
    out.push(i); // 이때 nmber[] 로 타입이 진화
  }
  return out;
}
```

- `out`은 처음에 `any[]`로 추론된다.
- `number`를 push하면서 최종적으로 `number[]`로 진화한다.

```ts
// 단계별 타입
const out = []; // any[]
out.push(1); // number[]
```

- 배열뿐만 아니라 조건문에서도 진화

---

## 2️⃣ 진화(evolve)는 타입 좁히기와 다르다

타입 좁히기는 **가능한 타입을 줄이는 것**이고,  
타입 진화는 **새로운 타입을 추가하며 확장하는 것**이다.

```ts
const result = []; // any[]
result.push("a"); // string[]
result.push(1); // (string | number)[]
```

## 3️⃣ null로 시작하는 경우도 진화

```ts
let val = null; // 타입 any

try {
  val = 12;
} catch (e) {
  console.warn("alas!");
}

val; // number | null
```

- 초기값이 `null`이어도 암시적 any는 진화한다.
- 주로 `try/catch` 블록에서 자주 발생한다.

---

## 4️⃣ 중요 포인트

(1) 명시적 any는 진화하지 않는다

```ts
let val: any;

if (Math.random() < 0.5) {
  val = /hello/;
} else {
  val = 12;
}

val; // any
```

- 명시적으로 `any`를 선언하면 타입은 **끝까지 any로 유지**된다.
- 진화는 **암시적 any**에서만 발생한다 (`noImplicitAny` 기준).

---

(2) any는 할당될 때만 진화한다

- 값을 **할당할 때만** 진화가 발생한다.
- 값을 읽기만 하면 오류가 발생한다.

```ts
let x;
x; // ❌ 암시적 any 사용 오류
```

---

(3) 함수 호출은 any를 진화시키지 않는다

```ts
function makeSquares(start: number, limit: number) {
  const out = []; // any[]
  range(start, limit).forEach((i) => {
    out.push(i * i);
  });
  return out;
}
```

- `forEach`의 콜백은 타입 추론에 영향을 주지 않는다.
- 이 경우 `out`은 끝까지 `any[]`로 남을 수 있다.

---

## 5️⃣ 더 나은 설계 방향

- 암시적 any의 진화에 의존하지 말 것
- 배열과 변수는 **초기화 시점에 명시적으로 타입 선언**
- `map`, `filter` 등 표현식 기반 로직을 활용해 타입을 안전하게 유지

👉 **any가 진화하도록 내버려두기보다, 처음부터 타입을 명확히 하자.**
