## Item 42 모르는 타입의 값에는 any 대신 unknown을 사용하기 

### any, unknown, never

- any가 강력하면서도 위험한 이유는 다음 두 가지 특징으로부터 비롯됨 
  - 어떠한 타입이든 any 타입에 할당 가능함
  - any 타입은 어떠한 타입으로도 할당 가능함
  - 한 집합은 다른 모든 집합의 부분 집합이면서 동시에 상위집합이 될 수 없기 때문에, 분명히 any는 타입 시스템과 상충되는 면을 가지고 있음

```ts
type Person = {
  name: string;
  age: number;
}
const something: any = {
  name: "John",
  age: 30
}
const person: Person = something; // type error 안남
```

- **unknown**은 any의 첫 번째 속성(**어떠한 타입이든 unknown에 할당 가능**)을 만족하지만, 두 번째 속성(**unknown은 오직 unknown과 any에만 할당 가능**)은 만족하지 않음

```ts
type Person = {
  name: string;
  age: number;
}

const unknownValue : unknown = {
  name: "Doe",
  age: 25
}

const anotherPerson: Person = unknownValue; // type error 발생
```

- **never** 타입은 **unknown type과 반대**로 **어떤 타입이든 never에 할당할 수 없**지만 **어떠한 타입으로든 할당 가능**함

```ts
// never는 모든 타입의 서브타입 (할당 가능)
const n: never = neverValue2; // OK
const s: string = neverValue2; // OK
const p: Person = neverValue2; // OK

// 하지만 never 변수는 실제로 값을 가질 수 없음
let neverValue: never;
neverValue = 123; // Error: Type 'number' is not assignable to type 'never'
```

### `{}`, `Object`, `unknown` 타입 차이

#### 결론

- **`{}`**: null과 undefined를 제외한 모든 값을 허용합니다 [TypeScript 공식 문서 - Object Types](https://www.typescriptlang.org/docs/handbook/2/objects.html)

> TypeScript 공식 문서에서 "{} describes an object with no properties" 라고 명시되어 있지만, 실제로는 null과 undefined를 제외한 모든 타입을 허용합니다.

- **`Object`**: 모든 객체 타입을 나타내며, 원시 타입(primitive)도 박싱되어 허용됩니다 [TypeScript Deep Dive - Object vs object](https://basarat.gitbook.io/typescript/type-system/moving-types#object-vs-object)

> "Object is the type of all instances of class Object. It is defined by the JavaScript standard library and includes all primitive types"

- **`unknown`**: 모든 값을 허용하지만 타입 검사 없이는 사용할 수 없습니다 [TypeScript 공식 문서 - unknown](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type)

> "unknown is the type-safe counterpart of any. Anything is assignable to unknown, but unknown isn't assignable to anything"

### Generic보다 Unknown을 써야하는 이유 

**unknown은 타입 검증을 강제**하지만, **Generic은 호출자가 거짓말해도 막을 수 없음**

#### 핵심 차이점

```typescript
// ❌ Generic - 호출자의 거짓말을 막을 수 없음
function parseJSON<T>(json: string): T {
  return JSON.parse(json); // 함수는 T를 보장할 수 없음
}

// 호출자가 잘못된 타입을 주장하면 그대로 통과
interface Admin { name: string; permissions: string[]; }
const admin = parseJSON<Admin>('{"name": "John"}'); // 컴파일 성공
admin.permissions.forEach(p => console.log(p)); // 💥 런타임 에러!

// ✅ Unknown - 사용자가 반드시 검증해야 함
function parseJSONSafe(json: string): unknown {
  return JSON.parse(json);
}

const result = parseJSONSafe('{"name": "John"}');
// result.permissions // ⛔ 컴파일 에러! 검증 필요

// 검증 후 사용 (타입 가드)
function isAdmin(obj: unknown): obj is Admin {
  return typeof obj === 'object' && obj !== null &&
         'name' in obj && 'permissions' in obj &&
         Array.isArray((obj as any).permissions);
}

if (isAdmin(result)) {
  result.permissions.forEach(p => console.log(p)); // ✅ 안전
} else {
  console.log('Invalid admin data'); // 에러 처리
}
```

- 차이점:
  - **Generic**: 함수는 타입을 보장할 책임이 없음 → 호출자 신뢰 기반 (위험)
  - **unknown**: 함수 사용자가 타입을 검증할 책임 → 강제 검증 (안전)
- 약간 벌금내고하는 스터디같은 느낌..


## Item 43 몽키 패치보다는 안전한 타입을 사용하기

### 몽키 패치(Monkey Patch)란?

런타임에 객체나 클래스의 정의를 동적으로 수정하는 기법. "[guerrilla patch](https://kangmin517.tistory.com/entry/%EB%AA%BD%ED%82%A4%ED%8C%A8%EC%B9%98Monkey-patch%EB%9E%80)"에서 유래했으며, 마치 영리한 원숭이가 코드를 몰래 수정한다는 의미를 담고 있음.

### JavaScript에서의 문제

JavaScript는 prototype 언어라서 런타임에 객체 정의를 변경할 수 있음:

```ts
window.monkey = 'Tamarin';
document.monkey = 'Howler';

// 프로토타입에도 추가 가능
RegExp.prototype.monkey = 'Capuchin';
/123/.monkey; // "Capuchin"
```

**문제점:**
- 전역 변수가 되어 프로그램 전체에 의존성 생성
- 예상치 못한 부작용(side effect) 발생

### TypeScript에서의 문제

타입 체커가 임의로 추가한 속성을 인식하지 못함:

```ts
document.monkey = 'Tamarin';
// Error: 'Document' 유형에 'monkey' 속성이 없습니다.

// any 사용은 타입 안전성과 언어 서비스 상실
(document as any).monkey = 'Tamarin'; // 타입 체크 무력화
```

### 해결책 1: interface 보강(Augmentation)

```ts
interface Document {
  /** 몽키 패치의 속(genus) 또는 종(species) */
  monkey: string;
}

document.monkey = 'Tamarin'; // 정상
```

**장점:**
- 타입 안전성 확보 (오타/잘못된 타입 체크)
- 주석 및 자동완성 지원
- 명확한 기록 유지

**모듈 영역 문제:**
- 보강은 전역으로 적용되어 코드 다른 부분과 분리 불가
- 런타임에 조건부 적용 불가능
- 모듈(import/export 사용)에서는 `declare global` 필요:

```ts
export {};
declare global {
  interface Document {
    monkey: string;
  }
}
```

### 해결책 2: 사용자 정의 인터페이스 단언

```ts
interface MonkeyDocument extends Document {
  monkey: string;
}

(document as MonkeyDocument).monkey = 'Macaque';
```

**장점:**
- 모듈 영역 문제 해결 (import하는 곳에만 적용)
- 필요한 곳에서만 선택적 사용 가능

### 결론

- 전역 변수나 DOM에 데이터 저장 지양
- 불가피한 경우 interface 보강 또는 사용자 정의 인터페이스 사용
- 궁극적으로는 데이터를 분리한 구조로 리팩터링 권장

## Item 44 타입 커버리지를 추정하여 타입 안정성 유지하기

- noImplicityAny가 설정되어 있어도, 명시적 any 또는 서드파티 타입 선언(@types)을 통해 any 타입은 코드 내에 여전히 존재할 수 있다는 점을 주의해야 함
- 작성한 프로그램의 타입이 얼마나 잘 선언되었는지 추적해야 함
- https://github.com/Techtaurant/fe/pull/5