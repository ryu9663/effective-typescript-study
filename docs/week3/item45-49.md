# Item 45 - 49

## Item 45: devDependencies에 typescript와 @types 추가하기

- devDependencies: 개발환경에서 사용되지만 production에서는 사용되지 않는 라이브러리들 (ex: 테스트 라이브러리)
- dependencies: 개발환경에서는 물론 production에서도 사용되는 라이브러리들
- peerDependencies: 꼭 필요하지만 의존성을 직접 관리하지 않는 의존성들. 공유 라이브러리등을 npm 패키지로 배포할 때 쓰인다. (사용자가 제공하도록)

=> TS는 개발환경에서 컴파일되어 사라지기 때문에 devDependencies다. 라이브러리의 타입정보를 담은 @types또한 마찬가지

## Item 46: 타입 선언과 관련된 세가지 버전 이해하기

TS에서 외부 라이브러리를 쓸때는 3가지 버전이 맞아야함. 그렇지 않으면 엉뚱한곳에서 에러가 날 수 있다.

- 실제 라이브러리 버전 (ex: react@16.8.6)
- 타입선언 (ex: @types/react@16.8.19)
- TypeScript 버전

타입은 설계를 나타내는 역할을 한다. @types 모듈의 패치 버전은 버그, 누락등으로 인한 수정과 추가에 따른 것이다.  
타입과 라이브러리의 업데이트가 맞지 않는 경우, 새로운 기능이나 deprecated 된 기능에 타입 오류가 나타날 것이다.  
어쩌면 **타입 체크를 통과했는데 런타임에 에러가 터질 수 있다.**

TS 버전도 마찬가지다. 일반적으로 JS 라이브러리들은 타입을 더 정확하게 표현하기 위해 TS 버전을 올리기 때문에 이에 맞춰줘야 한다.

**TS에서 의존성을 관리한다는건 쉽지 않지만 잘 관리한다면 올바르게 사용하는 방법에 도움이 되며 생산성 역시 크게 향상된다.**

-> 타입이 지나치게 좁거나 넓은 경우가 있는데 사용자들이 알아서 고치도록 공개 커뮤니티에서 관리하도록 하는 것이 좋다. (ex: https://github.com/sLeeNguyen/react-flip-clock-countdown/pull/26)

## Item 47

라이브러리 만들려면 모든 타입 export 시켜라. 사용자를 위해서

그리고 숨기고 싶어해도 어차피 ReturnType, Parameters 같은걸로 다 뽑아낼 수 있어서 은닉은 불가능하다. 그러니 차라리 쉽게 쓰도록 꺼내줘라

## Item 48

사용자를 위한 주석이라면 JSDocs로 만들어라. 호버하면 보이도록

```ts
/**
 * 인사하는 함수
 */
function greeting() {
  console.log("hihi");
}
```

필요하면 @param, @returns 같은 태그를 써서 사용법/의도/제약을 명확히 남기기.￼

주석에 타입 정보를 복붙하지 말고, 타입은 타입으로 표현

### '이건 string입니다' 같은 건 TS가 말해줌

```ts
// ❌ 나쁜 예: 타입을 주석으로 복붙(쉽게 구버전 됨)
/**
 * userId는 string 입니다.
 */
function getUser(userId /*: string */) {
  // ...
}

// ✅ 좋은 예: 타입은 타입으로, 주석은 의도/제약만
/**
 * 사용자 조회.
 * - userId는 DB에서 발급된 ID여야 함(임의 문자열 X)
 * - 존재하지 않으면 null 반환
 */
export async function getUser(userId: string): Promise<User | null> {
  // ...
  return null;
}
```

### 주석은 왜 그런지(의도), 무엇을 보장하는지(불변조건), 엣지케이스처럼 타입만으로는 전달이 어려운 걸 적는 쪽이 효율적이다. ￼

```ts
export type ParseResult =
  | { ok: true; value: number }
  | { ok: false; reason: "empty" | "nan" | "out_of_range" };

/**
 * 문자열을 안전하게 숫자로 파싱.
 * - 공백/빈 문자열이면 { ok:false, reason:"empty" }
 * - 숫자가 아니면 { ok:false, reason:"nan" }
 * - min/max 범위를 벗어나면 { ok:false, reason:"out_of_range" }
 * - 성공 시 value는 min..max 범위 내임을 보장
 */
export function parseBoundedInt(
  input: string,
  min: number,
  max: number
): ParseResult {
  const trimmed = input.trim();
  if (trimmed.length === 0) return { ok: false, reason: "empty" };

  const n = Number(trimmed);
  if (!Number.isFinite(n) || !Number.isInteger(n))
    return { ok: false, reason: "nan" };
  if (n < min || n > max) return { ok: false, reason: "out_of_range" };

  return { ok: true, value: n };
}
```

### 주석과 코드가 동기화되는것을 유념하기

```ts
// ❌ 나쁜 예: 주석이 구버전 되기 쉬움
/**
 * @returns null을 반환할 수 있음
 */
export function findById(id: string): User {
  // ← 실제로는 null 반환 안 함
  // 구현 바뀌었는데 주석이 남아있음(거짓 문서)
  return { id } as User;
}

// ✅ 좋은 예: 반환 가능성은 타입으로 드러내고, 주석은 의미만
/**
 * id로 사용자를 찾는다. 존재하지 않으면 null.
 */
export function findById(id: string): User | null {
  return null;
}
```

### 타입으로 표현 할 수 있는건 타입으로 표현하기

```ts
// ❌ 나쁜 예: 불변을 주석으로만 적음
/**
 * options는 절대 수정하지 마세요(불변).
 */
export function buildQuery(options: { keyword: string; page: number }) {
  // 실수로 수정해버릴 수 있음
  options.page = 1;
  return options;
}

// ✅ 좋은 예: 불변조건을 타입으로 강제
export type QueryOptions = Readonly<{
  keyword: string;
  page: number;
}>;

/**
 * 검색 쿼리 생성.
 * - 입력 options는 불변으로 취급(함수 내부에서 수정 불가)
 */
export function buildQuery(options: QueryOptions) {
  // options.page = 1; // ✅ 컴파일 에러
  return { ...options, page: Math.max(1, options.page) };
}
```

## Item 49: 콜백에서 this에 대한 타입 제공하기

### this는 호출방식에 따라 달라진다.

```ts
class C {
  vals = [1, 2, 3];
  logSquares() {
    console.log("디스", this);
    for (const val of this.vals) {
      console.log(val * val);
    }
  }
}

const c = new C();
// this는 메소드가 자신을 호출한 객체를 나타내는데,(화살표함수 제외)
// 메소드만 꺼내면서 바인딩이 끊기고 this가 undefined가 된다.
const method = c.logSquares;

//디스 undefined
///Users/ryujunyeol/Desktop/study/effective-typescript-study/mission-template/dist/48.js:8
//        for (const val of this.vals) {
// TypeError: Cannot read properties of undefined (reading 'vals')
method();
```

this의 이런 예측 불가능한 속성이 있으니 아무거나 바인딩하게 두지 말고 타입으로 못박는게 좋다.

### 화살표 함수 이용하기

```ts
class ResetButton {
  // 화살표 함수: this가 항상 인스턴스로 고정됨
  onClick = () => {
    console.log("Resetting", this);
  };

  render() {
    return makeButton({ text: "Reset", onClick: this.onClick });
  }
}
```

### this를 명시적으로 바인딩하기

여기서 fn의 첫 매개변수 this는 '이 콜백은 this가 HTMLElement로 호출된다'를 표현하는 가짜 파라미터이다.
-> 런타임에 없는데 타입체크를 위해 TS가 끼워넣는 파라미터

```ts
function addKeyListener(
  el: HTMLElement,
  fn: (this: HTMLElement, e: KeyboardEvent) => void
) {
  el.addEventListener("keydown", (e) => {
    fn.call(el, e);
  });
}
```
