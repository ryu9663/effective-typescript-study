# 📂 [Week 2] Item 19~23: 타입 추론과 제어 흐름

## 🏷️ Metadata

- **학습일:** 2025년 12월 26일
- **주차:** #Week2
- **키워드:** #타입추론 #타입넓히기 #타입좁히기 #변수분리 #객체생성 #TypeGuard #as_const

## 🚀 핵심 요약

> [!abstract] 이 섹션의 핵심 한 줄
> "타입스크립트의 강력한 추론 능력을 믿고 맡기되(Item 19, 21), 모호한 상황에서는 명확한 제어 흐름(Item 20, 22)과 올바른 객체 생성 패턴(Item 23)으로 타입을 좁혀나가야 한다."

## ✍️ 주요 내용 정리

### Item 19. 추론 가능한 타입을 사용해 장황한 코드 방지하기

- 변수 선언 시 모든 곳에 타입을 명시하는 것은 비생산적이다.
    - `let x: number = 12;` (불필요) → `let x = 12;` (충분함)
- 명시가 필요한 경우는
    - **객체 리터럴:** 잉여 속성 체크(Excess Property Check)를 활성화하여 오타를 잡고 싶을 때.
    - **함수 반환 타입:** 구현과 의도를 분리하고 싶을 때. 함수 내부 로직이 변경되어도 반환 타입이 의도치 않게 바뀌는 것을 방지하며, 문서화 효과를 준다.
- 추론을 권장하면서도 반환 타입만큼은 명시하자는것이 요점이다.
    - 함수의 내부를 수정하더라도 반환 타입이 변하는 것을 방지한다.
- 개인적인 생각이자만
    - 컨벤션 특성을 고려하여 모든 변수에 타입을 명시하는것이 좋을지 모른다.
    - 여러 개발자들과 개발하다보면 처음 구현의도와 현재 상태가 달라질 수 있으므로 타입을 명시하는 것이 좋을지도 모른다.

### Item 20. 다른 타입에는 다른 변수 사용하기

- 변수의 타입 범위가 `string | number`로 넓어지면(Union Type), 사용할 때마다 타입을 체크해야 하는 번거로움이 생기기 때문이다.
    - 분리, 구체적인 변수명, 타입 추론 향상,간결해지는 타입 등
    - 혼동 방지의 목적도 있다. 예를 들어 부동소수점 이슈가 있을때 bigNumber 에 인자를 number 을 줄 경우 문제가 발생할 수 있다. 이런 경우는 무조건 string 또는 bigNumber 타입을 줘야한다.
- 변수 재사용(mutating)보다는 **새로운 `const` 변수**를 선언한다. 이는 변수 가리기(Shadowing)나 별도 이름을 사용하여 목적을 명확히 해야한다.

### Item 21. 타입 넓히기 (Type Widening)

- 런타임에 모든 변수는 유일한 값을 가지지만, 컴파일 타임(작성 시점)에 타입스크립트는 가능한 값들의 집합(타입)을 추론해야 한다. 이를 **넓히기**라고 한다
- `let x = 'x';` 라고 쓰면 TS는 `x`의 타입을 `'x'`(리터럴)가 아니라 `string`으로 추론한다.
    - 나중에 다른 문자열이 할당될 수 있기 때문이다.
- 제어 방법
    - `const` 사용: 재할당이 불가능하므로 더 좁은 타입(리터럴)으로 추론된다.
    - `as const` 단언문(타입 캐스팅): 객체나 배열을 리터럴 타입 그대로 고정하고 싶을 때 가장 좋은 도구이다. Redux 액션 타입 정의 등에 필수적이다.

### Item 22. 타입 좁히기 (Type Narrowing)

- 넓은 타입(예: `HTMLElement | null`)에서 좁은 타입(예: `HTMLElement`)으로 정제하는 과정이다.
- 주요 기법 (Type Guard):
  1. **조건문:** `if (el) { ... }` (null 체크)
  2. **`instanceof`:** 클래스 인스턴스 확인
  3. **`in` 연산자:** 객체 내 특정 속성 존재 여부 확인
  4. **`Array.isArray`** 등 내장 함수 이용
  5. **`typeof`:** 원시 타입 확인
  6. **태그된 유니온 (Tagged Union):** `type: 'admin'` 같은 명시적 식별자 속성 사용 (가장 권장됨).
  7. **사용자 정의 타입 가드:** `function isInput(el): el is HTMLInputElement` 형태.
- `null` 체크 시 `typeof null`은 `'object'`임을 주의해야 하며, `0`이나 `""` 같은 Falsy 값을 필터링할 때 의도치 않은 결과가 나오지 않도록 해야한다.
    - [Falsy](https://developer.mozilla.org/ko/docs/Glossary/Falsy) 값은 언어 특성으로 알고 있어야한다.

### Item 23. 한꺼번에 객체 생성하기

- 객체를 생성할 때 빈 객체 `{}`를 만들고 속성을 하나씩 추가하면 타입스크립트에서는 에러가 발생한다. 초기 타입이 `{}`이기 때문이다.
- 객체 리터럴을 사용해 한 번에 정의하거나, 전개 연산자(`...`)를 사용해 객체를 합쳐야한다.
    - 전개 연산자는 얕은 복사(Shallow Copy) 이다. 중첩된 객체가 있다면 내부 객체는 참조값이 복사된다.
- 조건부 속성): 조건에 따라 속성을 추가하고 싶다면 전개 연산자와 헬퍼 함수를 조합하거나, 최신 문법인 `{ ...(condition ? {prop: val} : {}) }` 패턴을 사용해야한다.
- Lodash 라이브러리를 사용할 수 도 있다.
    - map, filter, forEach 가 IE8 에서 지원하지 않았다. 그래서 Underscore.js, Lodash 를 많이 사용했다.
        - 브라우저 호환성의 문제도 있다.
    - ES6(ES2015)부터 람다식, 전개 연산자, map, filter 등 추가되었지만 map을 자바스크립트에서 사용하기엔 null, undefined 에서 에러가 발생하여 Lodash 를 많이 사용했었다.
        - Lodash 를 사용하면 방어적으로 개발이 가능했다.
    - ES2020 지금은 Lodash 를 쓸 필요가 있나 싶다.
        - Lodash 의 `get(obj, 'a.b.c')` 에서  옵셔널 체이닝(`obj?.a?.b?.c`) 등 대체 가능하다.
        - 용량도 무겁다.

---

## 💻 코드 예시

**❌ 지양해야 할 코드 (Anti-pattern)**

```typescript
// Item 19: 불필요한 타입 명시(타입 추론)
const x: number = 10;

// Item 20: 변수 재사용 (타입이 string | number가 되어 사용 시 불편)
let id: string | number = 12345;
id = "12-345";

// Item 21: 의도치 않은 타입 넓히기
let config = {
  method: "GET", // string으로 추론됨
  url: "/api/items",
};
// function fetch(url: string, method: 'GET' | 'POST') 함수에 넣을 때 오류 발생 가능

// Item 23: 객체 쪼개서 만들기
const pt = {};
// @ts-ignore 또는 타입 단언을 강제로 써야 함
(pt as any).x = 3;
(pt as any).y = 4;
```

**✅ 지향해야 할 코드 (Best Practice)**

```typescript
// Item 19: 타입 추론 활용 + 객체 리터럴에는 타입 명시(오타 방지)
interface Product {
  id: string;
  name: string;
  price: number;
}
const product: Product = {
  // 잉여 속성 체크 활성화
  id: "p-001",
  name: "pc",
  price: 150000,
};

// Item 20: 변수 분리 (const 사용)
const idNumber = 12345;
const idString = "12-345";

// Item 21: as const로 타입 넓히기 방지 (리터럴 유지)
const config = {
  method: "GET",
  url: "/api/items",
} as const;
// config.method는 이제 'GET' 타입임 (readonly)

// Item 22: 태그된 유니온을 활용한 타입 좁히기
interface UploadEvent {
  type: "upload";
  filename: string;
}
interface DownloadEvent {
  type: "download";
  url: string;
}
type AppEvent = UploadEvent | DownloadEvent;

function handleEvent(e: AppEvent) {
  if (e.type === "upload") {
    // 여기서 e는 UploadEvent로 좁혀짐
    console.log(e.filename);
  } else {
    // 여기서 e는 DownloadEvent
    console.log(e.url);
  }
}

// Item 23: 객체 한꺼번에 생성 및 조건부 속성 추가
const defaultMeta = { createdAt: new Date() };
const extraMeta = { createdBy: "User" };
const isUpdated = true;

const metadata = {
  ...defaultMeta,
  ...extraMeta,
  ...(isUpdated ? { updatedAt: new Date() } : {}), // 조건부 속성 추가 팁
};
```

---

```ts
// bad case : 모든 속성을 다 가진 하나의 인터페이스 (Item 32 위반)
// "유니온의 인터페이스" (속성이 섞여 있음)
interface Action {
  type: string; // 너무 넓은 타입 (Item 21 문제: 리터럴이 아님)
  payload?: User; // 성공했을 때만 있음
  error?: string; // 실패했을 때만 있음
}

function reducer(state: State, action: Action) {
  // 문제점: action.type이 'LOGIN_FAIL'이어도 TS는 payload에 접근하는 것을 막지 못함
  if (action.type === "LOGIN_FAIL") {
    console.log(action.payload.name); // 런타임 에러 (undefined.name)
    // TS는 payload가 있을 수도 있다고 생각함 (User | undefined)
  }
}
```

- 인터페이스의 유니온(Union of Interfaces) : 각 액션별로 타입을 분리하고, `type` 속성을 리터럴 타입(Tag)으로 고정한다.
- Item 21의 `as const` 활용도 가능하다.

```ts
// 1. 각 액션을 명확하게 정의 (Interface의 Union)
interface LoginRequestAction {
  type: "LOGIN_REQUEST"; // 판별자(Discriminant) 태그
  // payload 없음
}

interface LoginSuccessAction {
  type: "LOGIN_SUCCESS";
  payload: { userId: number; name: string }; // 성공 시에만 존재
}

interface LoginFailureAction {
  type: "LOGIN_FAILURE";
  error: string; // 실패 시에만 존재
}

// 2. 액션들을 하나로 묶음 (Union)
type AuthAction = LoginRequestAction | LoginSuccessAction | LoginFailureAction;
```

- 리듀서에서 타입 좁히기 (Item 22)
- 리듀서(Reducer)의 `switch` 가 TypeScript의 `type` 태그를 보고 나머지 객체를 추론한다.

```ts
function authReducer(state: State, action: AuthAction) {
  // 처음 들어올 때 action은 3가지 가능성이 모두 있음

  switch (action.type) {
    case "LOGIN_REQUEST":
      // 여기서 action은 자동으로 LoginRequestAction으로 좁혀짐
      return { ...state, isLoading: true };

    case "LOGIN_SUCCESS":
      // TS는 type이 SUCCESS면 무조건 payload가 있다고 알고 있다.
      // action = LoginSuccessAction
      return {
        ...state,
        isLoading: false,
        user: action.payload, // 안전하게 접근 가능
      };

    case "LOGIN_FAILURE":
      // TS는 type이 FAILURE 면 무조건 payload가 있다고 알고 있다.
      // User가 없으니 payload에 접근하면 에러가 남
      console.log(action.payload); // ❌ Error: Property 'payload' does not exist...
      return {
        ...state,
        isLoading: false,
        error: action.error,
      };

    default:
      return state;
  }
}
```

- 타입 좁히기 (Type Widening) 방지
- 액션 생성 함수(Action Creator)를 만들 때 `as const`가 없다면 태그가 사라진다.

```ts
// as const 없음 -> 타입 넓혀짐
const loginSuccess = (data: User) => {
  return {
    type: "LOGIN_SUCCESS", // TS 추론: string
    payload: data,
  };
};
// 반환 타입: { type: string; payload: User }
// -> 리듀서의 switch 문에서 'LOGIN_SUCCESS'와 매칭되지 않음 (string은 너무 넓어서)

// ✅ as const 사용 -> 리터럴 타입 유지
const loginSuccess = (data: User) => {
  return {
    type: "LOGIN_SUCCESS",
    payload: data,
  } as const;
};
// 반환 타입: { readonly type: '*LOGIN_SUCCESS*'; readonly payload: User }
// 리듀서가 정확하게 인식함
```

- 타입스크립트에서 말하는 태그
- 값이 무작위 문자열(`string`)이 아니라, `food` 와 `electronics`라는 고정된 값(리터럴)인 것이 핵심이다.
- 태그를 통해 box.category 가 food 라고 한다면 expireDate 가 있다고 타입스크립트가 추론할 수 있다.

```ts
// 1. 식품 상자 (태그: 'food')
interface FoodBox {
  category: "food";
  expireDate: Date;
}

// 2. 전자제품 상자 (태그: 'electronics')
interface ElectronicsBox {
  category: "electronics";
  warranty: string;
}

type Parcel = FoodBox | ElectronicsBox;
```

- 모든 객체가 같은 이름의 속성을 가지고 있어야 한다. (위 예시에서는 `category`, 리덕스에서는 보통 `type`)
- 고유한 리터럴 값: 그 속성의 값이 `string` 처럼 뭉뚱그려져 있으면 안 되고, **`'upload'`, `'download'`** 처럼 정확히 고정된 값이어야 한다.
- 실무에서 자주 쓰는 태그 이름
    - `type`: (가장 흔함, Redux 표준)
    - `kind`: (많이 사용됨)
    - `tag`: (직관적임)
    - `status`: (상태 관리할 때 `'pending' | 'success' | 'error'`)
- 태그된 유니온(Tagged Union) 이라는 말은, 서로 다른 타입들을 합쳐놨는데(Union), 각 타입을 구별할 수 있는 명찰(Tag)이 붙어 있다 는 뜻
