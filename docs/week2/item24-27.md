# 아이템 24: 일관성 있는 별칭 사용하기

## 요약 개요

<별칭은 타입스크립트가 타입을 좁히는 것을 방해한다>

- Item 22 에서 '타입 체커는 일반적으로 타입 좁히기를 잘 해내지만, 타입 별칭이 있으면 그러지 못할 수 도 있다' 고 Warning 함.

- 그렇다면 '왜 타입 별칭이 타입 좁히기에 방해가 되는가?' 와 '어떻게 해결해야 하나' 에 대한 관점으로 요약.

---

## 1️⃣ 별칭이 타입 좁히기를 방해하는 이유

```ts
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  const box = polygon.bbox;

  if (polygon.bbox) {
    // ❌ box는 여전히 BoundingBox | undefined
    if (pt.x < box.x[0] || pt.x > box.x[1]) {
      return false;
    }
  }
}
```

### 왜 이런 일이 생길까?

- `polygon.bbox` → if 문 안에서 **BoundingBox로 좁혀짐**
- `box` → 같은 값을 가리키는 **별칭(alias)**

👉 타입을 좁힌 대상과 사용하는 변수가 서로 달라지면서 문제가 생김

---

## 2️⃣ Golden Rule: 별칭은 일관성 있게 사용한다

> **하나의 값에는 하나의 이름만**

- 타입 체크에 사용하는 이름
- 실제 로직에서 사용하는 이름

👉 **항상 동일해야 한다.**

---

## 3️⃣ 올바른 패턴 1: 지역 변수 하나만 사용

```ts
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  const box = polygon.bbox;

  if (box) {
    if (pt.x < box.x[0] || pt.x > box.x[1]) {
      return false;
    }
  }
}
```

- 타입 좁히기 정상 동작
- 별칭 혼용 제거
- 가독성 개선
  > 지역 변수 사용시 타입 안정성 얻는 이점: 외부에서 변경될 수 없다고 가정되기 때문에 TS가 타입 좁히기를 끝까지 신뢰

---

## 4️⃣ 올바른 패턴 2: 객체 비구조화 사용하여 일관된 이름 사용하기

```ts
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  const { bbox } = polygon;

  if (bbox) {
    const { x, y } = bbox;
    if (pt.x < x[0] || pt.x > x[1]) {
      return false;
    }
  }
}
```

- 중첩 접근 제거
- 이름 통일
- 타입 안정성 유지

---

## 객체 비구조화를 사용할 때 **두 가지 주의점**

### ⚠️ 1. 전체가 아니라 “부분만” 꺼내면 체크 범위가 달라진다

```ts
const { x, y } = bbox;
```

이 순간 타입스크립트는 더 이상  
**“bbox 전체가 안전하다”**는 정보를 사용하지 않는다.

**정리**

- 전체 객체로 검사했다면
- **전체 이름(`bbox`)으로 계속 사용하라**

---

### ⚠️ 2. 비구조화하면서 이름을 바꾸면 별칭 문제가 다시 생긴다

```ts
const { bbox: box } = polygon;
```

이제 코드에는:

- `polygon.bbox`
- `box`

두 이름이 동시에 존재한다.

타입스크립트 입장에서는  
**“지금은 같아 보여도, 앞으로도 같을지 확신할 수 없다”**.

**정리**

- 비구조화하더라도 **이름은 유지**
- 같은 값에 이름을 여러 개 붙이지 말 것

---

# 아이템 25: 비동기 코드에는 콜백 대신 async 함수 사용하기

## 요약: 왜 async 함수인가?

요약의 핵심 문장은 다음 세 가지

- 콜백보다 프로미스가 코드 작성과 타입 추론에 유리
- 가능하면 프로미스를 직접 만들기보다 `async / await`를 사용
- 어떤 함수가 프로미스를 반환한다면 `async`로 선언

> Callback < Promise < async / await

---

## 1️⃣ 콜백의 문제: 실행 순서 + 타입 추론 붕괴

콜백 기반 비동기 코드는 다음 문제를 동시에 가진다.

- 실행 순서가 코드 순서와 다름
- 중첩 구조로 가독성 급락 (callback hell)
- 에러 전파가 어렵고, 타입 추론도 거의 불가능

```ts
fetchURL(url1, (r1) => {
  fetchURL(url2, (r2) => {
    fetchURL(url3, (r3) => {
      console.log(1);
    });
    console.log(2);
  });
  console.log(3);
});
console.log(4);
// 출력: 4 → 3 → 2 → 1
```

👉 **코드를 읽는 순서 ≠ 실행 순서**

---

## 2️⃣ [ES2015] Promise가 해결한 첫 번째 문제

Promise 체인은 콜백보다 낫다.

```ts
fetch(url1)
  .then((r1) => fetch(url2))
  .then((r2) => fetch(url3))
  .catch((err) => {
    /* ... */
  });
```

### 개선점

- 중첩 감소
- 에러 처리 지점 통합
- 타입스크립트가 Promise 체인을 따라 타입을 추론 가능

하지만 여전히:

- `.then()` 체인은 길어지면 읽기 어려움
- try/catch 사용 불가

---

## 3️⃣ [ES2017] async / await

```ts
async function fetchPages() {
  const r1 = await fetch(url1);
  const r2 = await fetch(url2);
  const r3 = await fetch(url3);
}
```

### 여기서 해결되는 것들

- 실행 순서 = 코드 순서
- 동기 코드처럼 읽힘

### - await: 각각의 promise 가 resolve 가 될때까지 함수의 실행을 멈춤

### - asny: 함수 내에서 await 중인 promise 가 reject 되면 예외를 던지고, 이를 통해 try/catch 구문을 사용

```ts
async function fetchPages() {
  try {
    const r1 = await fetch(url1);
    const r2 = await fetch(url2);
  } catch (e) {
    // 모든 비동기 오류를 한 번에 처리
  }
}
```

👉 Promise 관련 오류를 일관된 방식으로 다룰 수 있게 만든다

---

## 4️⃣ async는 항상 Promise 기반 비동기를 강제한다

> async 함수가 Promise 오류를 막는 결정적 이유

### (1) 항상 Promise를 반환한다

```ts
async function getNumber() {
  return 42;
}
// 타입: () => Promise<number>
```

👉 동기/비동기 값을 섞어서 반환하는 구조를 원천적으로 차단

---

### (2) Promise 중첩을 자동으로 평탄화

```ts
async function getJSON(url: string) {
  const res = await fetch(url);
  return res.json(); // Promise<any>
}
```

- 반환 타입: `Promise<any>`
- ❌ `Promise<Promise<any>>` 아님

👉 비동기 함수가 지켜야할 규칙을 함수 선언 단계에서 명확히 고정

> 결론: async는 단순히 편의 문법이 아닌,
> Promise 기반 비동기 계약을 강제해 구조적 오류를 줄이는 가장 안전한 방식

---

# 아이템 26: 타입 추론에 문맥이 어떻게 사용되는지 이해하기

## 요약에서 출발: 이 아이템의 핵심

- 타입스크립트의 타입 추론은 **값 자체보다 문맥(context)**
- 즉, 문맥을 잃으면 추론도 무너지고, 그 순간에 타입 선언이 필요

---

## 1️⃣ 문맥이 살아 있는 경우: 인라인 리터럴

```ts
type Language = "JavaScript" | "TypeScript" | "Python";

function setLanguage(language: Language) {}

setLanguage("JavaScript"); // 정상
```

- 함수 시그니처가 **문맥 제공**
- `'JavaScript'`는 `Language`에 포함
- 타입스크립트는 사용 위치 기준으로 타입을 좁힌다

---

## 2️⃣ 문맥이 사라지는 순간: 변수 분리

```ts
let language = "JavaScript";
setLanguage(language); // ❌ string은 Language에 할당 불가
```

- `language`는 할당 시점에 `string`으로 추론
- 이후 호출 문맥은 영향을 주지 못함

👉 문맥은 변수 선언 시점에 끊김

---

## 3️⃣ 해결책 1: 타입 선언으로 문맥 복원

```ts
let language: Language = "JavaScript";
setLanguage(language); // 정상
```

- 변수 선언에 문맥을 명시
- 오타도 컴파일 타임에 검출 가능

---

## 해결책 2: 진짜 상수라면 as const

- as const 로 상수 문맥 부여

```ts
const loc = [10, 20] as const;
```

- 배열/객체 안의 값까지도 상수처럼 취급
- 리터럴/튜플 타입으로 유지

---

## as const의 단점: 오류 위치가 멀어진다

```ts
const loc = [10, 20, 30] as const;
panTo(loc); // ❌ 오류는 여기서 발생
```

- 원인은 정의 시점
- 오류는 사용 시점
- 규모가 커질수록 디버깅 난이도 증가

---

## 4️⃣ 튜플, 객체, 콜백에서도 같은 문제 발생

- 문맥이 사라지면 타입 추론이 무너진다
- 이 값이 어디에 쓰이느냐 라는 문맥을 함께 보고 타입을 결정

> 타입스크립트는 값 자체만 보고 타입을 추론하지 않기 때문

### 문맥이 끊기는 순간

- 값을 변수로 분리할 때
- 객체를 임시 변수로 뽑을 때
- 콜백을 별도 함수로 떼어낼 때

👉 문제 발생: 타입이 넓어지거나(any), 정확성을 잃음

## 5️⃣ 해결책을 다시 정리해보자

- 타입 선언으로 문맥을 직접 복원
- as const 로 상수 문맥 유지

> **문맥이 깨졌다면, 타입으로 복원하라.**

---

# 아이템 27: 함수형 기법과 라이브러리로 타입 흐름 유지하기

## 요약 - 알고 들어가기

- 타입 흐름(type flow)을 유지하려면 직접 루프를 작성하기보다 **내장 함수형 메서드(map, filter, reduce, flat 등)** 와 **검증된 유틸리티 라이브러리**를 사용하는 것이 좋다.
- 함수형 기법은 **입력을 변경하지 않고 새 값을 반환**하기 때문에 타입 추론이 자연스럽게 이어진다.
- 반대로 절차형(루프 기반) 코드는 **중간 변수에서 타입 정보가 쉽게 깨지며**, 명시적 타입 선언을 반복적으로 요구한다.

> 어떤 코드 스타일이 타입 정보를 끝까지 유지해주는가?

---

## 1️⃣ 왜 직접 루프는 타입 흐름을 깨는가

### 문제 상황

```ts
let allPlayers = [];

for (const players of Object.values(rosters)) {
  allPlayers = allPlayers.concat(players);
}
```

- `allPlayers`는 초기값이 `[]`라서 `any[]`로 추론됨
- 이후 어떤 값을 넣어도 타입 정보가 복구되지 않음
- 타입 오류는 늦게, 멀리서 발생

👉 **타입 추론의 출발점이 잘못되면 끝까지 복구되지 않는다**

---

## 2️⃣ 해결책 1: 명시적 타입 선언 (하지만 번거롭다)

```ts
let allPlayers: BasketballPlayer[] = [];

for (const players of Object.values(rosters)) {
  allPlayers = allPlayers.concat(players);
}
```

- 타입 문제는 해결됨
- 하지만 코드가 길어질수록 **타입 관리 비용 증가**

---

## 3️⃣ 해결책 2: 내장 함수형 메서드로 타입 흐름 유지

```ts
const allPlayers = Object.values(rosters).flat();
```

- 타입을 자동으로 끝까지 전파
- 타입스크립트가 중간 타입을 자동 추론
- 명시적 타입 선언 불필요

👉 **함수형 메서드는 타입 흐름을 끊지 않는다**

---

## 4️⃣ 함수형 기법의 핵심 특징

- 입력 배열을 변경하지 않는다
- 항상 새 값을 반환한다
- 반환 타입이 입력 타입으로부터 계산된다

```ts
const names = allPlayers.map((p) => p.name); // string[]
const salaries = allPlayers.map((p) => p.salary); // number[]
```

👉 이 구조 덕분에 타입 체커가 끝까지 따라올 수 있다

---

## 5️⃣ 로대시(Lodash)가 타입 추론에 강한 이유

```ts
const names = _.map(allPlayers, "name"); // string[]
const salaries = _.map(allPlayers, "salary"); // number[]
```

- 문자열 리터럴 + 인덱스 타입 조합
- 내부적으로 매우 정교한 타입 정의 제공
- 콜백 대신 **속성 이름만 전달해도 타입 유지**

---

## 6️⃣ 왜 라이브러리를 쓰는 게 오히려 안전한가

- 로대시/내장 메서드는
  - 수년간 검증됨
  - 엣지 케이스를 타입으로 이미 처리
- 직접 구현하면
  - 로직 + 타입 설계를 동시에 해야 함
  - 실수 가능성 증가

> 결론: 타입을 흐르게 만들어라
