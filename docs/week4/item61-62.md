## Item 61 의존성 관계에 따라 모듈 단위로 전환하기

- 점진적 마이그레이션을 할 때는 모듈 단위로 각개격파하는 것이 이상적임.
- 최하단 모듈부터 작업을 시작해서 의존성의 최상단에 있는 모듈을 마지막으로 완성해야 함.
- 서드파티 라이브러리 타입 정보를 가장 먼저 해결해야 함.
  - 일반적으로 @types 모듈을 설치하면 됨.
  - ex: loadsh -> @types/loadash
- **마이그레이션 할 때는 타입 정보 추가만 하고, 리팩터링을 해서는 안됨**.   
  - 목적을 잊지말자!!!
  - 잘못된 설계 그대로 타입스크립트로 전환하는 것은 납득하기 어려운 일이지만, 절대로 리팩터링을 하면 안됨.
- 자바 스크립트는 클래스 멤버 변수를 선언할 필요가 없지만, 타입스크립트에서는 명시적으로 선언해야 함.

```ts
class Greeting { 
  // Parameter 'name' implicitly has an 'any' type.ts(7006)
  constructor(name) {
    // Property 'greeting' does not exist on type 'Greeting'.ts(2339)
    this.greeting = 'Hello';
    // Property 'name' does not exist on type 'Greeting'.ts(2339)
    this.name = name;
  }

  greet() {
    return this.greeting + ' ' + this.name;
  }
}
```

- 아래 코드는 자바스크립트일 때는 문제가 없지만, 타입스크립트가 되는 순간 오류가 발생함.
  - 타입 단언문은 임시 방편이고 속성 값들을 미리 선언하는 것이 좋음. 
  - badge 마이그레이션 썰.

```js
const state = {};
state.name = 'New York';
state.capital = 'Albany';
```

- JSDoc과 @ts-check를 사용해 타입 정보를 추가한 상태라면 타입스크립트로 전환하는 순간 타입 정보가 무효화 됨.
  - JavaScript 파일에서 TypeScript의 타입 체킹을 활성화하는 주석
  - 자매 상품 : @ts-nocheck (특정 파일의 타입 체킹 비활성화), @ts-ignore (다음 줄의 타입 오류 무시)
  - Typescript 의존성이 있는 Javascript 프로젝트에서 점진적 마이그레이션을 할 때 유용함

```ts
/**
 * @param {number} num
 */
function double(num) {
  return num * 2;
}
// 위 코드는 아래 코드로 변경되면서 타입정보를 삭제해야 함.
function double(num: number): number {
  return num * 2;
}
```

- 테스트 코드는 항상 의존성 관계도의 최상단에 위치하며 마이그레이션의 마지막 단계가 되는 것은 자연스러운 일임. 
  - ~~TDD에서는 그렇게 하면 안되던데...~~

## Item 62 마이그레이션의 완성을 위해 noImplicitAny 설정하기

- noImplicitAny가 설정되지 않은 상태에서는 타입 선언에서 비롯되는 실제 오류가 숨어 있기 때문에 마이그레이션이 완료되었다고 할 수 없음.
- 아래 코드는 책에서 noImplicityAny 설정을 켜기 전과 후 에러값이 다르다고 함.
  - vscode에서는 내 설정이 뭔가 이상해서 그런지 무조건 에러가 발생함.
  - tsc를 활용해서 noImplicitAny 설정을 켜고 껏을 때 에러가 다르게 발생.

```bash
npx tsc practice/test-book-example.ts --noEmit --noImplicitAny true --strict false
npx tsc practice/test-book-example.ts --noEmit --noImplicitAny false --strict false
```

```ts
class Chart {
  indices: number[];

  constructor(data: number[]) {
    this.indices = data;
  }

  getRanges() {
    for (const r of this.indices) {
      // "number에 [0] 접근은 불가능하지만..."
      // "억지로 허용한다면 결과는 any가 될 수밖에 없음"
      // 결과 타입이 암묵적으로 any가 됨
      const low = r[0];
      const hight = r[1];
    }
  }
}
```

- 처음에는 로컬에서만 설정하는것을 권장.
- 가장 강력한 설정은 "strict": true 모드임.