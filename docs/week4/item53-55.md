# 아이템 53: 타입스크립트 기능보다는 ECMAScript 기능을 사용하기

## 요약

- 일반적으로 타입스크립트 코드에서 **모든 타입 정보를 제거하면 자바스크립트가 되지만**,  
  열거형(enum), 매개변수 속성, 트리플 슬래시 임포트, 데코레이터는  
  타입 정보를 제거해도 **순수 자바스크립트가 되지 않는다**.
- 타입스크립트의 역할을 명확히 하려면  
  **열거형, 매개변수 속성, 트리플 슬래시 임포트, 데코레이터는 사용하지 않는 것이 좋다.**

---

## 왜 이런 문제가 생겼을까?

타입스크립트가 등장한 2010년대 초반, 자바스크립트에는 다음 기능들이 없었다.

- class
- decorator
- 공식 모듈 시스템
- enum 같은 값 집합 표현

그래서 타입스크립트는 초기에 **언어 기능 자체를 확장**하는 방식으로 발전했다.  
하지만 이후 TC39가 자바스크립트 표준(ECMAScript)을 빠르게 확장하면서,
타입스크립트 고유 기능과 **표준 자바스크립트 기능이 충돌**하기 시작했다.

결국 타입스크립트 팀은 다음 원칙을 선택했다.

> **런타임 기능은 ECMAScript에 맡기고,  
> 타입스크립트는 타입 시스템에만 집중한다.**

---

## 열거형(enum)

### 숫자 열거형의 문제

```ts
enum Flavor {
  VANILLA = 0,
  CHOCOLATE = 1,
  STRAWBERRY = 2,
}
```

문제점:
- 지정 값 이외의 숫자도 할당 가능
- 런타임에 객체가 생성됨(상수 열거형은 런타임에 완전히 제거)

---

### 문자열 열거형도 완전한 해법은 아니다

- 타입 안전성은 개선
- 하지만 여전히 **런타임 코드가 생성**
- 구조적 타이핑이 아닌 **명목적 타이핑**

---

### 리터럴 유니온 타입

```ts
type Flavor = "vanilla" | "chocolate" | "strawberry";
```

장점:
- 런타임 코드 없음
- 자바스크립트와 완벽히 호환

---

## 매개변수 속성 (Parameter Properties)

```ts
class Person {
  constructor(public name: string) {}
}
```

문제점:
- 런타임 동작이 코드에 숨겨짐
- 일반 속성과 혼용 시 설계 혼란

### 해결: 명시적 스타일

```ts
class Person {
  name: string;
  constructor(name: string) {
    this.name = name;
  }
}
```

---

## 네임스페이스 & 트리플 슬래시 임포트

- ES2015 이전 모듈 시스템의 잔재
- 현대 ESM 환경과 부적합

---

## 데코레이터

- 아직 표준이 완전히 확정되지 않음
- 런타임 동작이 불투명

---

## 최신 동향 (2024~2025 기준)

### enum
- 대부분의 신규 프로젝트에서 enum 지양
- `as const` + 리터럴 유니온 패턴 선호

### 데코레이터
- TypeScript 5.x에서 새 데코레이터 문법 지원
- 프레임워크 외 일반 코드에서는 사용 빈도 낮음

### 매개변수 속성
- 대규모 코드베이스에서 점점 기피
- 명시적 필드 선언 선호

### 네임스페이스
- 신규 프로젝트에서는 거의 사용되지 않음

---

## 결론

- 타입스크립트는 **타입 시스템**이다.
- 런타임 기능은 ECMAScript 표준을 우선하자.
- 타입스크립트 전용 문법은 가급적 피하자.

👉 **자바스크립트를 더 잘 쓰는 것이 곧 타입스크립트를 잘 쓰는 것이다.**


---
# 아이템 54: 객체를 순회하는 노하우

## 요약

- 객체를 순회할 때 가장 중요한 것은 **“이 객체에 어떤 키가 들어올 수 있는가”**를 정확히 이해하는 것이다.
- `keyof`와 `for-in`은 **키 집합이 정확히 고정되어 있을 때만** 안전하다.
- 대부분의 실무 상황에서는 **`Object.entries`가 가장 현실적이고 안전한 선택**이다.

---

## 객체 순회에서 문제가 생기는 진짜 이유

타입스크립트에서 객체를 순회할 때 문제가 생기는 이유는 문법 때문이 아니라  
**타입스크립트가 객체를 바라보는 관점** 때문이다.

핵심은 이 한 문장이다:

> **함수의 매개변수로 전달되는 객체에는,  
> 타입에 선언되지 않은 추가 키가 존재할 수 있다.**

이 가정 때문에 타입스크립트는 객체 순회를 매우 보수적으로 처리한다.

---

## for-in 루프가 위험해지는 이유

`for-in` 루프에서 순회 변수는 항상 `string` 타입으로 취급된다.  
이는 자바스크립트 런타임 특성상 **객체의 키가 문자열이기 때문**이다.

```js
for (const key in obj) {
  // key는 항상 string
}
```

하지만 타입스크립트의 객체 타입은 보통  
`"a" | "b" | "c"` 같은 **구체적인 키 유니온**을 가진다.

```ts
type Obj = {
  a: number;
  b: number;
};
```

이 두 관점이 충돌하면서 문제가 발생한다.

- 런타임 관점: “모든 키는 string”
- 타입 관점: “이 객체의 키는 제한된 집합”

---

## 프로토타입 오염이라는 숨은 위험

`for-in`은 객체 자신의 속성뿐 아니라  
**프로토타입 체인에 있는 속성까지 순회**한다.

실무에서는 다음을 항상 염두에 둬야 한다.

- 예상하지 못한 키가 등장할 수 있다
- 전역 객체나 라이브러리가 프로토타입을 오염시킬 가능성
- 순회 결과가 환경에 따라 달라질 수 있음

이 문제는 타입으로 완벽히 막을 수 없다.  
**순회 방식 선택 자체가 방어 수단**이다.

---

## keyof가 항상 정답이 아닌 이유


`keyof`를 사용하면 키 타입을 구체화할 수 있다.  

```ts
for (const key of Object.keys(obj) as (keyof Obj)[]) {
  obj[key];
}
```

하지만 이는 **중요한 전제가 필요**하다.

> 이 객체에는 **정말로 추가 키가 없다**는 전제

하지만 함수 인자로 객체를 받는 순간, 이 전제는 깨진다.


--- 

## Object.entries가 기본 선택지가 되는 이유

`Object.entries`는 타입스크립트의 이상과  
자바스크립트의 현실 사이에서 **의도적으로 타협한 API**다.

```ts
Object.entries(obj).forEach(([key, value]) => {
  // key: string
  // value: any
});
```

- 키는 항상 `string`
- 값은 `any`

타입은 느슨하지만, 대신 다음을 보장한다.

- 런타임 동작과 정확히 일치
- 추가 키, 예기치 않은 속성에 안전
- 복잡한 타입 퍼즐이 필요 없음

👉 **“객체를 그냥 순회하고 싶다”**라는 목적에는  
이 정도 타입 정보가 오히려 가장 적절하다.


---

## 실무 기준으로 정리하면

### `keyof + for-in`을 써도 되는 경우
- 객체가 상수에 가깝고
- 키 집합이 완전히 고정되어 있으며
- 외부 입력이 아닌 경우

👉 드문 케이스

### `Object.entries`를 쓰는 경우
- 함수 인자로 받은 객체
- API 응답, 설정 객체, 옵션 객체
- “키와 값을 그냥 처리하고 싶을 때”

👉 **대부분의 실무 코드**

---

## 결론

- 객체 순회 문제는 **타입 문제 이전에 설계 문제**다.
- 타입을 더 정교하게 만드는 것이 항상 정답은 아니다.
- 대부분의 경우, **런타임 현실을 그대로 반영하는 방식이 더 안전**하다.

---

# 아이템 55: DOM 계층 구조 이해하기

## 요약

- **Dom 에는 명확한 타입 계층 구조가 있고, 타입스크립트에서는 이 구조를 이해하지 않으면 에러가 난다.**

---

## DOM 계층 구조 한눈에 보기

DOM 타입은 다음과 같은 상속 구조를 가진다.

```
EventTarget
  └─ Node
      └─ Element
          └─ HTMLElement
              └─ HTMLDivElement / HTMLButtonElement / ...
```

- **Element 와 HTMLElement 구조를 기억하라**

예시:

| 타입 | 예시 |
|---|---|
| EventTarget | window, XMLHttpRequest |
| Node | document, Text, Comment |
| Element | HTMLElement, SVGElement |
| HTMLElement | <div>, <p>, <button> |
| HTMLButtonElement | <button> |

---

## Event 타입 계층 이해하기

`Event`는 가장 추상적인 이벤트 타입이다.

구체적인 이벤트 타입:
- `MouseEvent`
- `KeyboardEvent`
- `TouchEvent`
- `WheelEvent`

- 구체적인 이벤트들은 각자 자기만의 속성을 갖고 있다.

---

## DOM 타입 오류를 해결하는 두 가지 방법

- 1. 매개변수 타입을 구체화하기
- 2. 문맥 기반 타입 추론 사용하기


---

## DOM 에서 타입 단언이 허용되는 경우

```ts
const div = document.getElementById("my-div") as HTMLDivElement;
```

- 엘리먼트가 반드시 존재함을 **확신할 수 있을 때만** 사용
- 타입 단언은 편의 기능이지, 안전 장치가 아닙니다.

---

## 실무 규칙 (Rule of Thumb)

- `Event` 대신 `MouseEvent`, `KeyboardEvent`
- `Element` 대신 `HTMLElement`
- 타입 단언보다 **문맥 기반 추론 우선**

---

## 결론

- DOM은 타입 계층 구조를 가진 시스템이다.
- 구체적인 타입과 문맥 추론이 최고의 해법이다.

👉 **DOM 타입을 이해하면, 타입스크립트가 훨씬 쉬워진다.**
