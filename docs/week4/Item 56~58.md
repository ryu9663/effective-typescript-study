# 📂 [Week 4] Item 56~58: 정보 은닉, 디버깅, 모던 JS

## 🏷️ Metadata

- **학습일:** 2026년 1월 18일
- **주차:** 4주차
- **키워드:** #정보은닉 #private #closure #해시필드 #소스맵 #디버깅 #모던자바스크립트

## 🚀 핵심 요약

> [!abstract]
> 타입스크립트의 `private`은 런타임에 효력이 없으므로
>
> 1. 정보 은닉을 위해 클로저나 `#` 문법을 사용하고,
> 2. 소스맵을 통해 원본 코드로 디버깅하며,
> 3. 레거시 패턴 대신 모던 자바스크립트 문법을 적극 도입한다.

## ✍️ 주요 내용 정리

### Item 56. 정보를 감추는 목적으로 private 사용하지 않기

- **타입스크립트의 `private` 한계**:
  - `public`, `protected`, `private` 접근 제어자는 **컴파일 타임에만 유효**하다.
   컴파일된 자바스크립트 코드에서는 제거되며, 런타임에는 누구나 속성에 접근하거나 수정할 수 있다.
   단언문(`as any`)을 통해 타입 시스템을 우회하면 접근이 가능하다.
  - **진정한 정보 은닉 방법**:

 1. **클로저(Closure)**: 생성자나 함수 내부에서 변수를 선언하고 메서드에서만 접근하게 하여 외부 노출을 원천 차단한다.(메모리 오버헤드가 있을 수 있음)
 2. **비공개 필드(`#`)**: 최신 자바스크립트 표준인 `#` 접두사(Private Fields)를 사용한다.
    - 이는 런타임에서도 강제적인 비공개 속성이 되며, 클래스 외부에서 접근 시도 시 에러가 발생한다.
	- 과거에는 Private 하다는 것을 표현하기 위해 _ 를 접두사로 두기도하였다.
    `#` 문법은 ECMAScript 2020(ES2020, ES11) 때부터 지원하였다.

**코드 예시**

```ts
// 0-1 우회하여 접근하는 방법
class Diary {
 0-1 컴파일 타임에만 숨겨짐
 private secret: string = 'default';
}
// 0-1 타입 체크는 에러를 내지만, 런타임에 강제 형변환(as any)하면 접근 가능하여 정보 은닉에 실패함
const myDiary = new Diary();
console.log((myDiary as any).secret); 

// 1-1 생성자나 함수 내부에서 변수를 선언하고 메서드에서만 접근하게 하여 외부 노출을 원천 차단하는 방법
// 1-1 인스턴스가 생성될 때 마다 메서드가 생성되는 점은 주의해야 한다. 
function createCounter() {
 // 외부에서 절대 접근이 불가능하다.
 let count = 0;

 return {
  inc: () => count++, 
  get: () => count
 };
}

// 2-1 비공개 필드 # 해시를 사용하는 방법
class DiarySecure {
 // 2-1 #을 붙여 런타임 프라이빗 필드 선언
 #secret: string = 'default';

 constructor(secret: string) {
  this.#secret = secret;
 }

 // 2-1 클래스 내부에서만 접근 가능하다 
 check() {
  return this.#secret;
 }
}
const s = new DiarySecure('secret');
s.#secret // 런타임시 에러가 발생한다. (Syntax Error)
```

### Item 57. 소스맵을 사용하여 타입스크립트 디버깅하기

- **디버깅의 어려움**: 타입스크립트는 자바스크립트로 컴파일(Transpile)되어 실행되므로, 런타임 에러 발생 시 변환된 JS 코드를 보고 디버깅해야 하는 어려움이 있다. 변수명이나 구조가 바뀌어 원본 코드와 매칭하기 힘들다.
- **소스맵(Source Map)**: `tsconfig.json`에서 `"sourceMap": true`를 설정하면, `.js.map` 파일이 생성된다.
- 브라우저 디버거(Chrome DevTools 등)나 IDE가 이 파일을 이용해 **실행 중인 JS 코드와 원본 TS 코드를 매핑**해준다.
- 개발자는 원본 TS 코드에 브레이크포인트를 걸고 변수 값을 검사할 수 있어 디버깅 효율이 비약적으로 상승한다.
- **주의사항**: 상용 배포(Production) 시 소스맵을 함께 배포하면 원본 소스 코드가 외부에 노출될 수 있다. 보안이 중요하다면 프로덕션 빌드에서는 소스맵 생성을 끄거나, 별도의 인증된 서버에만 업로드해야 한다.

**코드 예시**

- tsconfig.json 설정 없이 디버깅을 했을 때
  - 컴파일된 JS 파일을 열어서 변환된 변수명(예: \_a, \_b)을 추측하며 디버깅해야 한다.
  - debugger; 구문을 넣어도 변환된 위치에서 멈춘다.
- 소스맵 생성 활성화를 했을 때
  - 브라우저 개발자 도구 -> Sources 탭에서 .ts 파일을 직접 열어 중단점 설정 가능하다.
  - 프로덕션 환경(배포용) 빌드 설정 예시 (보안 고려)
  - 별도의 빌드 스크립트나 CI/CD 파이프라인에서 제어
  - tsc --sourceMap false (소스 코드 노출 방지)

```json
{
  "compilerOptions": {"sourceMap": true}
}
```

### Item 58. 모던 자바스크립트로 작성하기

- **TS 컴파일러의 역할**: 타입스크립트는 최신 JS(ECMAScript) 문법을 구형 런타임(ES5 등)에서도 돌아가도록 변환해준다.
  따라서 개발자는 호환성 걱정 없이 최신 문법을 적극 사용하여 가독성과 생산성을 높여야 한다.
- **마이그레이션 대상 (레거시 -> 모던)**:
  - **모듈**: `require`/`module.exports` -> `import`/`export` (Tree Shaking 등 최적화 유리)
  - **클래스**: 프로토타입(`prototype`) -> `class` 문법 (구조적이고 명확함)
  - **변수**: `var` -> `let`/`const` (블록 스코프로 호이스팅 문제 해결)
  - **비동기**: 콜백(Callback)이나 `.then()` 체인 -> `async`/`await` (동기 코드처럼 작성 가능)
  - **반복문**: `for(;;)` -> `for-of` (인덱스 실수 방지)
- 아마 4년차 미만의 개발자들의 경우에는 레거시를 잘 보지 못했을 가능성이 클 것 같다. 만약 내가 모르는 문법이 나왔다면 문법을 검색해보고 모던하게 수정하면 될 것 같다.

**코드 예시**

```ts
// [레거시] 프로토타입과 var 사용 예시
function Person(name) { 
 this.name = name; 
}
Person.prototype.greet = function() { 
 return "Hello " + this.name; 
};
var me = new Person("Kim");

// [레거시] 콜백지옥 사용 예시 (괄호 열고 닫기가 빡셈)
function getData(cb) {
  loadUrl(
   url, 
   function(err, data) {
    save(
     data, 
     function(err) { 
      cb(data);
     }
    );
   }
  );
}

// [모던] 클래스, const 사용
class Person {
 constructor(public name: string) {} // 단축 초기화 구문 활용

 greet() { 
  return `Hello ${this.name}`; 
 }
}
const me = new Person("Kim");

// [모던[ async/await 사용
async function getData() {
 try {
  const data = await loadUrl(url);
  await save(data);
   
  return data;
 } catch (e) {
   // 에러 처리
 }
}


// [모던] CommonJS 대신 ES Modules 사용
import { Component } from './Component';

export class MyComponent extends Component {
  // ...
}
```

### 1. 호이스팅

코드가 실행되기 전에 자바스크립트 엔진이... 변수 선언부를 스코프의 **최상단으로 끌어올리는 것처럼 동작**하는 현상

- 스코프(Scope)란 변수, 함수 등이 유효하게 접근하고 사용될 수 있는 범위
- `var`와 `let/const`는 호이스팅이 되었을 때 **초기화(Initialization)** 과정이 다름
- **`var`:** 선언과 동시에 `undefined`로 **초기화**됨 (그래서 에러가 안 나고 `undefined`가 발생함)
- **`let/const`:** 선언은 되지만, 코드가 실제 선언 줄에 도달할 때까지 **초기화되지 않으며** 이 구간을 **TDZ**라고 부름
   TMZ --> Temporal Dead Zone, 일시적 사각지대
호이스팅 스코프 예시 1

```ts
console.log(myVar); // undefined
console.log(myLet); // ReferenceError!

var myVar = 10;
let myLet = 20;
```

호이스팅 블록 스코프 예시 2

```ts
// 전역 스코프
let name = "전역 변수";
function test() {
 // 블록 스코프 시작 
 // 지역 변수 name이 존재함을 인지하였지만 초기화가 안되서 TDZ 상황임
  
 console.log(name); // ReferenceError 발생함 
 // 원인: 전역 변수를 무시하고, 호이스팅된 지역 변수 name을 참조하려다 실패했기 때문임

 // 초기화가 되고 name 가 출력됨 (TDZ 종료)
 let name = "지역 변수"; 
 console.log(name);
}
```
