## 질문

인스턴스가 아님에도 class 내부의 함수를 변수에 할당할 수 있는 이유
그래서 this가 undefined가 될 수 있는데 왜 이따구로 설계했는가

## 답

- JS는 클래스 같은 무거운 모델이 아니라 브라우저 안에서 즉석으로 객체를 만들고 거기에 프로피티를 붙혀 쓰는 스크립트가 필요했음

- 이 언어의 이름을 뭘로할까? Java처럼 보이되 Java의 클래스/모듈 같은것은 피하는것이 언어의 컨셉 -> JavaScript로 하자!

- 당시 상황에서 가볍고 빠르게, 동적으로 조립하는 것을 목표로 하다보니 객체, 프로퍼티를 유연하게 조합할 수 있게 했다.

- 자바처럼 보이지만 클래스 기반 언어가 아니라 프로토타입 언어를 목표로 했음

  - 클래스기반 (Java, C#, C++)
    - 재사용 단위: 클래스
    - 상속: 타입, 구조를 먼저 고정하고 그 아래 인스턴스가 생김
    - 특징: 구조가 비교적 정적이고 설계가 명확하다. 큰 시스템에서 규칙 세우기 쉬움
  - 프로토타입 기반

    - 재사용 단위: 객체(프로토타입)
    - 상속: 부모 클래스 그런거 모르겠고 프로토타입 체인으로 계속 위로 올라감
    - 특징: 런타임에 객체,프로토타입을 바꿔가며 **동적으로 조립하기 쉬움**

      - ex: 배열 메서드는 진짜 배열이 아니어도 빌려 쓸 수 있게 설계되어 있다

        ```js
        const arrayLike = { 0: "a", 1: "b", length: 2 };

        const joined = Array.prototype.join.call(arrayLike, "-");

        console.log(joined); // "a-b"
        ```

  즉석으로 객체를 만들고 거기에 프로피티를 붙혀서 어디서든 조합 시킬 수 있는 스크립트가 필요했음
  => this를 메서드가 자신을 호출한 객체를 가리키도록 설계했어야 함
  => this가 undefined가 나오는 상황을 허용하는건 '프로토타입 언어'를 택한 결과로 자연스럽게 생기는 케이스
