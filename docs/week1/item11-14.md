# Item 11 잉여 속성 체크의 한계 인지하기 

## Excess Property Checks

- typescript는 필수조건만 충족한다면 **또 다른 어떤 속성**을 가지는 모든 객체는 해당 타입의 범위에 속함 (구조적 타이핑)

```ts
interface Options {
  title: string;
  darkMode?: boolean;
}

function createWindow(options: Options): void {
  const { title, darkMode = false } = options;
  console.log(`Creating window with title: ${title}`);
  if (darkMode) {
    console.log("Dart mode is enabled.");
  } else {
    console.log("Dart mode is disabled.");
  }
}

createWindow({ title: "My App" });
// 1. 문제 될 것 없는 코드지만 에러
// Object literal may only specify known properties, but 'darkmode' does not exist in type 'Options'. Did you mean to write 'darkMode'?ts(2561)
createWindow({ title: "My App", darkmode: true }); // 문제 될 것 없는 코드
const opts = { title: "My App", darkmode: true };
// 2. 에러도 발생 안함
createWindow(opts);
```

- 하지만 typescript에서는 **잉여 속성 검사** 또는 [초과 프로퍼티 검사(Excess Property Checks)](https://inpa.tistory.com/entry/TS-%F0%9F%93%98-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%9D%EC%B2%B4-%ED%83%80%EC%9E%85-%EC%B2%B4%ED%82%B9-%EC%9B%90%EB%A6%AC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0#%EC%B4%88%EA%B3%BC_%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0_%EA%B2%80%EC%82%AC_excess_property_checks)를 통해서 초과한 프로퍼티에 대한 검사를 해주게 된다. 
  - 그리고 초과프로퍼티 중에서 다른 특정한 프로퍼티가 값이 들어오지 않은게 있다면 해당 값을 의미했던 것은 아닌지?에 대한 추론도 해준다.
  - 그러나 이러한 **초과 프로퍼티 검사**는 객체 리터럴(중괄호를 사용해 데이터를 구조화하여 즉시 객체를 만드는 방법)에만 동작한다. (2번 케이스의 경우 동작 안함)

### Exactly Type 

- 이를 막기 위한 꼼수로 Exactly custom type을 사용하는 방법이 있다.

```ts
interface Options {
  title: string;
  darkMode?: boolean;
}

type Exactly<T, U> = T & Record<Exclude<keyof U, keyof T>, never>;

function createWindowExact<T extends Exactly<Options, T>>(options: T): void {
  const { title, darkMode = false } = options;
  console.log(`Creating window with title: ${title}`);
  if (darkMode) {
    console.log("Dart mode is enabled.");
  } else {
    console.log("Dart mode is disabled.");
  }
}

// 1. 에러 발생: 'darkmode' 속성은 'never' 타입과 호환되지 않습니다.
createWindowExact({ title: "My App", darkmode: true });

const opts = { title: "My App", darkmode: true };
// 2. 이제 이 경우에도 에러가 발생합니다.
createWindowExact(opts);
```

> Exclude<keyof U, keyof T>: U 타입에는 있지만, T 타입에는 없는 속성 키를 찾아냄 (Exclude<A, B> : 타입 A에서 입 타입B에 속하는 멤버 제외) <br>
> Record<K, V>: 키 K와 값 V를 가지는 객체 타입을 생성하는 유틸리티 <br>
> never: TypeScript에서 절대 발생하지 않는 타입(공집합) <br>

> Exclude<keyof U, keyof T>의 결과는 Exclude<("title" | "darkmode"), ("title" | "darkMode")>가 됨 -> 결과적으로 남는 것은 "darkmode" <br>
> 잉여 속성들의 타입(never 타입)을 강제로 지정하는 객체 타입을 만듬 <br>
> Record<"darkmode", nver>의 결과는 darkmode: nver 타입이 됨 
> 두 타입을 교차하여 결합 (T & { darkmode: never }) -> 공집합에 값이 들어가면서 타입 에러 발생!


- 초과 프로퍼티 검사는 타입 단언문을 사용할 때에도 적용되지 않습니다.

```ts
interface Options {
  title: string;
  darkMode?: boolean;
}

// 에러 발생 안함
const o: Options = { darkmode: true, title: 'Ski Free'} as Options;
```

## 약한 타입

- 선택적 속성만 가지는 **약한(weak) 타입에도 비슷한 체크가 동작합니다.

```ts
interface Person {
  name?: string;
  age?: number;
}

// 에러 발생
const p1: Person = { Name: "Alice", Age: 30 };
const p2 = { Name: "Bob", Age: 25 };
// 객체 리터럴이 아닌데도 에러 발생
const p3: Person = p2;
console.log(p1.name, p3.name);
```

- typescript 팀은 약한 타입 변수에 객체를 할당할 때는, 할당되는 객체의 속성 중 최소 하나 이상이 약한 타입 인터페이스의 속성과 일치해야 한다고 설명합니다.

```ts
interface Person {
  name?: string;
  age?: number;
}

const o2 = { name: "Bob", Age: 25 };
// 에러 발생 안함
const p4: Person = o2;
```

> Excess Property Checking and Weak Types in TypeScript are discussed in the official TypeScript Handbook's "Object Types" section and the TypeScript 2.4 release notes. The weak type checking behavior is a standard part of TypeScript, also referenced in various blogs and Stack Overflow answers. You can find more information on the [Microsoft TypeScript documentation](https://www.google.com/search?q=chrome&rlz=1C5CHFA_enKR1180KR1180&sourceid=chrome&ie=UTF-8&udm=50&aep=48&cud=0&qsubts=1766412205579&mstk=AUtExfCPfskDNMs_52KZldAay6X0F7cu_jggbdoVbvu-1yn15VL87yePp5G2z06i0I7oBUsUQCy8rQgTFT5zPw_T6tZa3sbBrMNAC-zV8NptMnGLw4eM4kONQUzHZdrvMHfEtlLOx26F-FkIg5YhQuVUt6X-RVECl0ngfwtcE40zQsdOSiTODuflyTsP2P37VVts6cTF-gRJGb9cVd6JXjI4wMb7Fss10MPjg2S3WMvgTqjXeC7vS-GmjsRY6Q&csuir=1) and resources. 

# Item 12 함수 표현식에 타입 적용하기 

- 동일한 시그니처가 반복되는 함수에 대해서 type을 정의함으로써 type 선언 시간을 줄일 수 있다.

```ts
type AsyncMiddleware = (req: Request, res: Response, next: NextFunction) => Promise<void>;

const authGuard: AsyncMiddleware = async (req, res, next) => { /* 인증 로직 */ };
const loggingMiddleware: AsyncMiddleware = async (req, res, next) => { /* 로그 로직 */ };
const rateLimiter: AsyncMiddleware = async (req, res, next) => { /* 제한 로직 */ };
```

- 다른 함수의 시그니처를 참조하려면 **typeof fn**을 사용할 수 있다.

```ts
function registerUser(name: string, age: number, isAdmin: boolean) {
  // 유저 등록 로직...
}

// registerUser의 인자들과 똑같은 인자를 받는 대기 함수(Proxy) 만들기
type RegisterParams = Parameters<typeof registerUser>;

const loggerBeforeRegister = (...args: RegisterParams) => {
  console.log("등록 시도 데이터:", args);
  // registerUser(...args); // 실제 함수 호출 시에도 완벽하게 타입 호환
};
```

- 특정 함수의 인자만 가져오기 위해 **Parameters**를 사용할 수 있다.

```ts
type calc = (x: number, y: number) => number;

const add: calc = (x, y) => x + y;
console.log(add(2, 3));

type AddParameters = Parameters<typeof add>;

const addprinter = (...args: AddParameters) => {
  console.log(`Adding ${args[0]} and ${args[1]} gives ${add(...args)}`);
};

addprinter(5, 10);
```

- 특정 함수의 반환 값을 Type으로 쓰기 위해 **ReturnType**을 사용할 수 있다.

```ts
type calc = (x: number, y: number) => number;
const add: calc = (x, y) => x + y;

// 1. add 함수의 반환 타입을 추출 (여기서는 number가 됩니다)
type AddResult = ReturnType<typeof add>;

// 2. 추출한 타입을 변수나 함수의 인자에 활용
const saveResult = (result: AddResult) => {
  console.log(`결과값 ${result}를 데이터베이스에 저장했습니다.`);
};

const result: AddResult = add(10, 20);
saveResult(result);
```

## 코드의 시그니처를 강제해서 의도치 않은 에러를 컴파일 타임에 잡아낼 수 있습니다. 

- /quote가 존재하지 않는 API라면 '404 Not Found'가 포함된 내용을 응답하며, 이는 JSON 형식이 아닐 수 있습니다.

```ts
async function getQuote() {
  const response = await fetch('/quote?by=Mark+Twain');
  const quote = await response.json();
  return quote;
}

// 결과 예시
// {
//   "quote": "If you tell the truth, you don't have to remember anything.",
//   "source": "notebook",
//   "date": "1894"
// }
```

- 상태 체크를 수행하는 checkedFetch를 함수 문장으로 작성하면 다음과 같습니다

```ts
async function checkedFetch(input: RequestInfo, init?: RequestInit) {
  const response = await fetch(input, init);
  if (!response.ok) {
    // 비동기 함수 내에서 거절된 프로미스로 변환합니다.
    throw new Error('Request failed: ' + response.status);
  }
  return response;
}
```

- 함수 문장을 함수 표현식으로 바꾸고 함수 전체에 타입(typeof fetch)을 적용하면 더 간결해집니다.

```ts
const checkedFetch: typeof fetch = async (input, init) => {
  const response = await fetch(input, init);
  if (!response.ok) {
    throw new Error('Request failed: ' + response.status);
  }
  return response;
}
```

- Error에 throw 대신 return을 사용했다면, 타입스크립트는 반환 타입이 fetch의 시그니처와 일치하지 않는다는 실수를 즉시 잡아냅니다.


# Item 13 타입과 인터페이스의 차이점 


## 공통점

- 인덱스 시그니처는 인터페이스와 타입에서 모두 사용할 수 있습니다.
- 함수 타입도 인터페이스나 타입으로 정의할 수 있습니다. 
- 타입 별칭과 인터페이스는 모두 제너릭이 가능합니다. 

```ts
// 1. Type Alias로 정의한 TState
type TState = {
  name: string;
  capital: string;
};

// 2. Interface로 정의한 IState
interface IState {
  name: string;
  capital: string;
}

type TPair<T> = {
  first: T;
  second: T;
}

interface IPair<T> = {
  first: T;
  second: T;
}
```

- 인터페이스는 타입을 확장할 수 있고 타입은 인터페이스를 확장할 수 있다.

```ts
interface IStateWithPop extends TState {
  population: number;
}
type TStateWithPop = IState & { population: number; };
```

- 클래스를 구현(implements)할 때는, 타입(TState)과 인터페이스(IState) 둘 다 사용할 수 있습니다.

```ts
// 1. Type Alias로 정의한 TState
type TState = {
  name: string;
  capital: string;
};

// 2. Interface로 정의한 IState
interface IState {
  name: string;
  capital: string;
}

class StateT implements TState {
  ...
}

class StateI implements IState {
  ...
}
```


## 차이점 

- 유니온 타입은 있지만 **유니온 인터페이스라는 개념은 없습니다**.
  - type 키워드는 일반적으로 interface보다 쓰임새가 많습니다.
- 인터페이스 내부에는 메서드가 존재할 수 없습니다. 
  - 인터페이스는 객체의 구조(데이터)만 정의할 뿐, Array.prototype의 기능(메서드)을 상속받지 않았습니다. 

```ts
// 튜플과 구조가 "비슷한" 인터페이스
interface ITuple {
  0: string;
  1: number;
  length: 2;
}

const myTuple: ITuple = ["hello", 123]; // 구조적으로는 맞아서 할당 가능 (Duck Typing)

// ❌ 에러 발생!
// Property 'concat' does not exist on type 'ITuple'.
myTuple.concat([456]);

// 타입 별칭을 이용한 진짜 튜플 정의
type TTuple = [string, number];

const myTuple2: TTuple = ["hello", 123];

// ✅ 성공! 
// TypeScript는 이것이 Array의 하위 타입임을 알고 있습니다.
const result = myTuple2.concat(["world"]); 
console.log(result); // ["hello", 123, "world"]
```

- interface는 type에는 존재하지 않는 **보강(augment)이 가능**하다.
  - 속성을 확장하는 것을 **선언 병합(declaration merging)**이라고 한다.
  - 예를 들어, Array 인터페이스는 [lib.es5.d.ts](https://github.com/microsoft/TypeScript/blob/2dfdbbabae955186f821925c629a37d8df76bab2/src/lib/es5.d.ts#L1307)에 정의되어 있는데, ES2015를 추가하면 [lib.es2015.d.ts](https://github.com/microsoft/TypeScript/blob/2dfdbbabae955186f821925c629a37d8df76bab2/src/lib/es2015.iterable.d.ts#L58)에 선언된 인터페이스를 병함한다.

```ts
interface IState {
  name: string;
  capital: string;
}
interface IState {
  population: number;
}

const wyoming: IState = {
  name: "Wyoming",
  capital: "Cheyenne",
  population: 500_000,
};

const keys = Object.keys(wyoming);

// 배열을 순회하며 출력
keys.forEach((key) => {
  console.log(key);
});

// 출력 결과:
// "name"
// "capital"
// "population"
```

- 일관되게 인터페이스를 사용하는 코드베이스에서 작업하고 있다면 인터페이스를 사용하고, 일관되게 타입을 사용 중이라면 타입을 사용하는게 좋다. 
- 어떤 API에 대한 타입 선언을 작성해야 한다면 인터페이스를 사용하는게 좋다. 
  - API가 변경될 때 사용자가 인터페이스를 통해 새로운 필드를 병합할 수 있어 유용하기 때문


## 인덱스 시그니처

- **인덱스 시그니처**(Index Signature)는 Typescript에서 "객체의 속성(Key) 이름은 정확히 모르지만, 그 속성들의 타입(Value)은 알고 있을 때" 사용하는 문법입니다.

```ts
interface StringArray {
  // index는 어떤걸로든 명칭을 붙일 수 있습니다.
  [index: number]: string;
}

const myArray: StringArray = ["Bob", "Fred"];
const myStr: string = myArray[0]; // index(0)은 number, 값("Bob")은 string
```

- 인덱스 시그니처가 있으면, 명시적으로 선언된 다른 속성들도 반드시 그 규칙을 따라야 합니다.

```ts
interface Dictionary {
  [key: string]: number; // "모든 문자열 속성의 값은 숫자여야 한다"고 선언함
  
  length: number; // (O) number라서 통과
  name: string;   // (X) Error! 'string'은 인덱스 시그니처의 'number'에 할당할 수 없음
}
```

- 만약 name처럼 다른 타입이 꼭 필요하다면 유니온 타입(|)을 써야 합니다.

```ts
interface Dictionary {
  [key: string]: number | string; // 값은 숫자거나 문자일 수 있다
  name: string; // (O) 이제 통과됨
}
```

## 프로토타입 체인 

자바스크립트라는 언어의 가장 핵심이면서도, 초보자들이 가장 헷갈려 하는 **'프로토타입 체인(Prototype Chain)'** 개념을 아주 쉬운 비유를 들어 설명해 드릴게요.

코딩 용어는 잠시 잊으세요. 우리는 지금부터 **"물건 빌리기"** 놀이를 할 겁니다.

---

### 1. 상황 설정: 내 가방과 아빠의 가방

당신(**자식**)이 있고, 당신의 **아빠**, 그리고 **할아버지**가 있다고 상상해 보세요. 그리고 각자 자기만의 **가방(객체, Object)**을 하나씩 메고 있습니다.

* **나의 가방:** `[스마트폰, 지갑]`
* **아빠의 가방:** `[자동차 키, 망치]`
* **할아버지의 가방:** `[고문서, 돋보기]`

자바스크립트의 세계에서는 이 세 사람을 **끈**으로 묶어 놓을 수 있습니다. 이것이 바로 **"연결(Chain)"**입니다.

> **나 —(연결)—> 아빠 —(연결)—> 할아버지**

### 2. 프로토타입 체인의 작동 원리 (물건 찾기)

이제 당신이 어떤 물건을 쓰고 싶어 한다고 칩시다. 자바스크립트는 당신이 물건을 찾을 때 다음과 같은 **3단계 규칙**으로 움직입니다.

#### 상황 1: 내가 가진 것을 찾을 때

"나는 **스마트폰**을 쓰고 싶어!"

1. 내 가방을 뒤집니다.
2. "어! 스마트폰 있네?"
3. **성공!** 바로 사용합니다. (아빠나 할아버지를 귀찮게 할 필요가 없습니다.)

#### 상황 2: 내가 없지만, 아빠가 가진 것을 찾을 때 (여기가 핵심!)

"나는 **망치**가 필요해!"

1. 내 가방을 뒤집니다. (없음)
2. 포기할까요? 아닙니다. 나랑 연결된 **아빠(프로토타입)**한테 갑니다.
3. 아빠 가방을 뒤집니다. "어! 아빠 가방에 망치가 있네?"
4. **성공!** 아빠의 망치를 빌려 씁니다.
* *마치 내 것처럼 자연스럽게 씁니다.*



#### 상황 3: 아빠도 없어서, 할아버지까지 갈 때

"나는 **돋보기**가 필요해!"

1. 내 가방 뒤짐. (없음)
2. 아빠한테 감. 아빠 가방 뒤짐. (없음)
3. 아빠랑 연결된 **할아버지(아빠의 프로토타입)**한테 갑니다.
4. 할아버지 가방 뒤짐. "찾았다! 돋보기!"
5. **성공!**

### 3. 이게 바로 '프로토타입 체인'입니다

위의 이야기에서 나온 개념을 자바스크립트 용어로 바꾸면 이렇습니다.

1. **가방 = 객체 (Object):** 데이터가 들어있는 통입니다.
2. **아빠 = 프로토타입 (Prototype):** 나에게 없는 능력을 대신 제공해 주는 **'원형(부모)'**입니다.
3. **끈으로 연결됨 = 체인 (Chain):** 내가 못 찾으면 자동으로 부모를 찾아가도록 연결된 구조입니다.

즉, **프로토타입 체인**이란 **"내가 능력이 없을 때, 내 부모(프로토타입)의 능력을 빌려 쓰기 위해 줄줄이 사탕처럼 연결된 구조"**를 말합니다.

### 4. 실제 코드로 느낌만 보기 (아주 간단히)

자바스크립트로는 이 상황을 이렇게 짭니다. (문법은 몰라도 됩니다. 흐름만 보세요!)

```javascript
// 1. 할아버지 (돋보기를 가짐)
const grandFather = { 돋보기: "오래된 돋보기" };

// 2. 아빠 (망치를 가짐)
const father = { 망치: "튼튼한 망치" };
// 아빠의 부모는 할아버지라고 연결!
father.__proto__ = grandFather; 

// 3. 나 (스마트폰을 가짐)
const me = { 스마트폰: "아이폰" };
// 나의 부모는 아빠라고 연결!
me.__proto__ = father; 

// ------------------------------------------

// Q: 나는 돋보기가 있나요? (내 코드엔 없죠?)
console.log(me.돋보기); 

// 결과: "오래된 돋보기"가 출력됩니다!
// (나 -> 아빠 -> 할아버지 순서로 찾아가서 가져옴)

```

### 5. 체인의 끝은 어디인가요? (중요)

할아버지의 아빠, 증조할아버지... 계속 올라가다 보면 끝이 있겠죠?

자바스크립트의 모든 객체(가방)의 조상을 계속 따라 올라가면, 결국 **`Object.prototype`**이라는 '최초의 조상'을 만나게 됩니다. (마치 인류의 시초인 아담과 이브처럼요.)

만약 이 최초의 조상 가방에도 없는 물건(예: `레이저총`)을 달라고 하면 어떻게 될까요?
더 이상 물어볼 부모가 없으므로, 자바스크립트는 비로소 **"없습니다(undefined)"**라고 대답합니다.

### 6. 그렇다면 인터페이스는?? 

> TypeScript는 Structural Typing(구조적 타이핑) 시스템을 사용하고, 인터페이스는 그 시스템 안에서 객체의 구조(Shape)를 정의하는 도구다.

**"객체의 구조(데이터)만 정의했다"**는 말을 아주 쉬운 비유로 설명해 드릴게요.

휴대폰 대리점에 가면 진열대에 놓인 **'목업폰(모형 휴대폰)'**을 보신 적 있나요? 이 목업폰이 바로 **인터페이스**와 똑같습니다.

---

#### 1. 비유: 진짜 스마트폰 vs 목업폰

##### (1) 목업폰 (인터페이스)

목업폰을 손에 들어보세요.

* **겉모양(구조)**은 진짜랑 똑같습니다.
* 앞면에 화면이 있고, 옆에 볼륨 버튼이 있고, 뒷면에 카메라 렌즈가 있습니다.
* 누가 봐도 "아, 이건 스마트폰 모양이네"라고 알 수 있습니다.

**하지만 전원 버튼을 눌러보세요.** 화면이 켜지나요? 전화를 걸 수 있나요?
**아니요, 안 됩니다.** 왜냐하면 안에는 배터리도, 반도체(CPU)도, **기능을 작동시키는 기계 장치(엔진)**가 전혀 없기 때문입니다. 그저 껍데기일 뿐이죠.

> **이게 바로 "구조만 정의했다"는 뜻입니다.**
> "이 객체는 화면이 있어야 하고, 버튼이 있어야 해"라는 **모양 규칙**은 지켰지만, 실제로 전화를 거는 **기능(메서드)**은 없다는 것이죠.

##### (2) 진짜 스마트폰 (Array.prototype을 상속받은 진짜 배열)

진짜 폰은 겉모양도 갖췄고, 그 안에 **삼성이나 애플이 심어놓은 소프트웨어(기능)**가 들어있습니다.

* 이 소프트웨어가 있기 때문에 전화를 걸고(`call`), 문자를 보내고(`send`), 앱을 켤 수 있습니다.
* 이 '심어놓은 소프트웨어'가 바로 프로그래밍 용어로 **`Array.prototype`**입니다.

---

#### 2. 코드로 다시 보기

질문하신 상황으로 돌아가 볼까요?

**인터페이스로 만든 튜플 (목업폰)**

```typescript
interface FakeTuple {
  0: string;    // 첫 번째 칸(화면) 있음
  1: number;    // 두 번째 칸(버튼) 있음
  length: 2;    // 길이(크기)도 맞음
}

```

* **상황:** 개발자가 "자, 여기 0번 데이터 있고, 1번 데이터 있고, 길이도 2야. 그러니까 이건 배열(튜플)이지?"라고 우기는 상황입니다.
* **현실:** TypeScript는 "어, 모양은 배열이랑 똑같이 생겼네(구조는 맞네). 근데 안에 **배열 엔진(Array.prototype)**이 안 들어있잖아?"라고 판단합니다.
* **결과:** 모양은 배열 같지만, 배열의 엔진이 없으므로 `concat`(붙이기), `push`(밀어넣기) 같은 **기능 버튼을 눌러도 아무 반응이 없거나 에러가 나는 것**입니다.

---

#### 3. 세 줄 요약

1. **객체의 구조만 정의했다**: "이건 자동차 모양 장난감이야. 바퀴 4개 있고 핸들 있어." (**껍데기 규격**)
2. **프로토타입 기능이 없다**: "근데 엔진이 없어서 실제로 굴러가진 않아." (**실제 작동 능력 부재**)
3. **결론**: 인터페이스로 튜플을 만들면 **'모양'은 흉내 낼 수 있지만, 배열이 가진 편리한 '기능(메서드)'들은 쓸 수 없습니다.**

### 요약

자바스크립트를 모르는 생초보를 위한 한 줄 요약:

> **"프로토타입 체인이란, 내 주머니에 없는 물건을 찾기 위해 아빠 주머니, 할아버지 주머니를 차례대로 뒤지는 '자동 검색 시스템'이다."**

이 시스템 덕분에 우리는 모든 기능을 내 가방에 다 넣고 다닐 필요 없이, 부모(프로토타입)가 가진 기능을 편하게 내 것처럼 가져다 쓸 수 있는 것입니다.

# Item 14 타입 연산과 제너릭 사용으로 반복 줄이기 

- 타입 중복은 코드 중복만큼 많은 문제를 발생시킵니다. 
- 타입 연산과 제너릭 타입을 사용해서 반복을 줄일 수 있습니다.

## Pick Type

```ts 
type Pick<T, K extends keyof T> = { [k in K]: T[k] }; 

type Person = {
  head: string;
  body: string;
}

type Airhead = Pick<Person, 'body'>;

const airhead: Airhead = {
  body: 'This is the body of the airhead person.'
};
```

## [Partial Type](https://github.com/microsoft/TypeScript/blob/2dfdbbabae955186f821925c629a37d8df76bab2/src/lib/es5.d.ts#L1567)

`Partial<T>`는 타입스크립트의 유틸리티 타입 중 가장 많이 쓰이는 것으로, **"모든 속성을 선택적(Optional)으로 만들어주는 도구"**입니다.

쉽게 말해, 필수 입력 항목이었던 것들을 모두 **"입력해도 되고 안 해도 되는 것"**으로 바꿔줍니다.

---

### 1. 코드 상세 해석

```typescript
type Partial<T> = {
  [P in keyof T]?: T[P];
};

```

이 코드는 **맵드 타입(Mapped Type)**이라는 문법을 사용합니다. 마치 `for` 문으로 객체의 속성을 하나씩 도는 것과 같습니다.

1. **`T`**: 변환하고 싶은 **원본 타입**입니다. (예: `User` 인터페이스)
2. **`keyof T`**: 원본 타입 `T`가 가진 **모든 키(속성 이름)들의 목록**을 뽑아옵니다.
* 예: `User`가 `name`, `age`를 가졌다면 `keyof User`는 `"name" | "age"`가 됩니다.
3. **`[P in keyof T]`**: 뽑아온 키 목록을 하나씩 순회합니다. (반복문)
* `P`는 현재 순회 중인 속성 이름(Key)입니다.
4. **`?`**: **핵심입니다.** 현재 속성 `P` 뒤에 물음표를 붙여서 **"있어도 되고 없어도 됨(Optional)"**으로 만듭니다.
5. **`T[P]`**: 속성의 **값(Value) 타입**은 원본(`T`)에 있던 것(`T[P]`)을 그대로 씁니다.

**결론:** 원본의 키와 값 타입은 유지하되, 모든 속성에 `?`를 붙여서 재탄생시킵니다.

---

### 2. 실제 동작 예시 (Before & After)

어떤 상황에서 `Partial`이 동작하는지 시뮬레이션해 보겠습니다.

#### 1) 원본 타입 (모두 필수)

```typescript
interface User {
  name: string;
  age: number;
  email: string;
}

// ❌ 에러 발생! (모든 속성이 다 있어야 함)
const user1: User = {
  name: "Cheolsu" 
}; 

```

#### 2) `Partial<User>` 적용 (모두 선택)

`Partial<User>`를 쓰면 타입스크립트 내부적으로 아래와 같이 변환됩니다.

```typescript
// 내부적으로 이렇게 변환됨
// type PartialUser = {
//   name?: string;
//   age?: number;
//   email?: string;
// }

// ✅ 성공! (일부만 있어도 됨)
const user2: Partial<User> = {
  name: "Cheolsu" 
};

// ✅ 성공! (아예 비어있어도 됨)
const user3: Partial<User> = {}; 
```

---

### 3. 실무에서는 언제 쓰나요?

가장 대표적인 사용 사례는 **"데이터 수정(Update)"** 기능을 만들 때입니다.

회원 정보를 수정할 때, 이름만 바꿀 수도 있고 나이만 바꿀 수도 있죠? 사용자가 무엇을 수정할지 모르기 때문에, 수정 함수를 만들 때는 모든 인자를 `Partial`로 받습니다.

```typescript
interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

// 할 일을 수정하는 함수
// fieldsToUpdate: Todo의 속성 중 '일부'만 들어옵니다.
function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {
  return { ...todo, ...fieldsToUpdate };
}

const myTodo: Todo = { title: "청소하기", description: "방 쓸고 닦기", completed: false };

// 1. 'completed'만 수정하고 싶을 때
updateTodo(myTodo, { completed: true });

// 2. 'title'과 'description'만 수정하고 싶을 때
updateTodo(myTodo, { title: "빨래하기", description: "흰 옷만" });
```

사용자님의 정리 스타일(헤더 구조, 설명 방식, 코드 주석 스타일, '쉽게 말해' 등의 화법)을 분석하여, **Item 14**의 연장선상에서 **Pick**과 **Partial** 외에 실무에서 자주 쓰이는 핵심 유틸리티 타입들을 정리해 드립니다.

---

## Omit Type

`Omit<T, K>`는 `Pick`의 정반대 개념으로, **"특정 속성만 제거하고 나머지(부분 집합)를 가져오는 도구"**입니다.

보통 인터페이스가 매우 거대한데, 거기서 딱 한두 개만 빼고 싶을 때 `Pick`으로 나머지를 다 나열하는 것보다 `Omit`으로 제거하는 게 훨씬 효율적입니다.

### 1. 코드 상세 해석

```ts
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;
```

`Omit`은 독자적인 맵드 타입이라기보다, `Pick`과 `Exclude`의 조합으로 이루어져 있습니다.

1. **`Exclude<keyof T, K>`**: `T`의 키 목록(`keyof T`) 중에서 제거하고 싶은 키 `K`를 뺍니다(제외).
2. **`Pick<...>`**: 위에서 남은 키들만 가지고 다시 `Pick`을 수행하여 새로운 타입을 만듭니다.

### 2. 실제 동작 예시

비밀번호 같은 민감한 정보를 클라이언트로 보낼 때 유용합니다.

```ts
interface User {
  id: number;
  username: string;
  email: string;
  passwordHash: string; // 절대 클라이언트에 보내면 안 되는 정보
}

// 비밀번호만 쏙 뺀 타입을 생성
type UserWithoutPassword = Omit<User, 'passwordHash'>;

const validUser: UserWithoutPassword = {
  id: 1,
  username: "user123",
  email: "test@test.com",
  // passwordHash: "..." // ❌ 에러 발생! 이 속성은 존재하지 않습니다.
};
```

## Required Type

`Required<T>`는 `Partial`의 정반대 역할을 합니다. **"모든 선택적(Optional) 속성을 필수(Required) 속성으로 바꿔주는 도구"**입니다.

### 1. 코드 상세 해석

```ts
type Required<T> = {
  [P in keyof T]-?: T[P];
};
```

1. **`[P in keyof T]`**: `T`의 모든 키를 순회합니다.
2. **`-?`**: **핵심입니다.** `?`(Optional) 수식어를 **제거(-)**한다는 뜻입니다. 원래 `name?: string`이었다면 `name: string`으로 강제 변환됩니다.

### 2. 실제 동작 예시

설정 객체 등에서 사용자가 일부만 입력해도 되지만(Optional), 내부 로직에서는 반드시 기본값이 채워진 상태(Required)로 다뤄야 할 때 씁니다.

```ts
interface Config {
  host?: string;
  port?: number;
}

// 사용자는 일부만 입력 가능
const userConfig: Config = { host: "localhost" };

// 하지만 내부 로직에서는 모든 값이 채워져 있어야 함
const completeConfig: Required<Config> = {
  host: userConfig.host || "localhost",
  port: userConfig.port || 8080
};

// ✅ 안전함: port가 무조건 number임이 보장됨 (undefined 아님)
console.log(completeConfig.port.toFixed(2)); 
```

## Readonly Type

`Readonly<T>`는 **"모든 속성을 읽기 전용(불변)으로 만들어주는 도구"**입니다. 생성 후에는 값을 절대 수정할 수 없게 막아줍니다.

### 1. 코드 상세 해석

```ts
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};
```

1. **`readonly`**: 맵드 타입 앞에 `readonly` 키워드를 붙여서, 생성된 모든 속성에 읽기 전용 속성을 부여합니다.

### 2. 실제 동작 예시

Redux의 상태(State)나 설정 상수처럼, 데이터가 도중에 변경되면 안 되는 경우 필수적입니다.

```ts
interface Todo {
  title: string;
}

const myTodo: Readonly<Todo> = {
  title: "Delete logs"
};

console.log(myTodo.title); // 읽기는 가능

// ❌ 에러 발생!
// Cannot assign to 'title' because it is a read-only property.
myTodo.title = "Update logs"; 
```

## 타입 정의를 먼저하고 값이 그 타입에 할당 가능하다고 선언하는 것이 좋다.

- 나쁜 예 

```ts
// 1. 값(구현)을 먼저 작성함
const INIT_OPTIONS = {
  path: '/home',
  useSsl: true,
  // ⚠️ 실수! 개발자가 오타를 냈습니다 (timeout -> timeOut)
  timeOut: 500
};

// 2. 값으로부터 타입을 뽑아냄 (설계가 구현을 따라감)
type Options = typeof INIT_OPTIONS;

// 결과: Options 타입은 이제 { path: string; useSsl: boolean; timeOut: number; }가 됩니다.
// 'timeOut'이라는 오타가 '공식적인 타입'으로 굳어져 버립니다.
```

- 좋은 예

```ts
// 1. 타입(설계도)을 먼저 정의함
interface Options {
  path: string;
  useSsl: boolean;
  timeout: number; // 정확한 이름을 미리 정함
}

// 2. 값이 그 타입에 맞는지 검사하면서 작성 (설계를 따름)
const INIT_OPTIONS: Options = {
  path: '/home',
  useSsl: true,
  // 🚨 에러 발생!
  // Object literal may only specify known properties, but 'timeOut' does not exist in type 'Options'.
  timeOut: 500 
};
```