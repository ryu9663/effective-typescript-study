# 아이템 15: 동적 데이터에 인덱스 시그니처 사용하기

## 1. 인덱스 시그니처가 하는 일

인덱스 시그니처는 “이 객체는 **어떤 키**가 와도 되고, 그 값은 **이 타입**이야” 라고 말합니다.

```ts
type Rocket = {
  [property: string]: string; // ✅ 키는 string, 값은 string
};

const rocket: Rocket = {
  name: "Falcon 9",
  variant: "v1.0",
  thrust: "4,940 kN",
};
```

- `[property: string]`의 `property` 이름은 **의미 없는 자리표시자**(타입 체크에 영향 없음)
- 키 타입은 보통 `string`을 씁니다(이외에도 `number | symbol` 가능)
- 값 타입은 무엇이든 가능

---

## 2. 인덱스 시그니처의 대표 단점 4가지

### (1) 오타 키도 다 허용됨

```ts
type Rocket = { [k: string]: string };

const r: Rocket = {
  Name: "Falcon 9", // ❌ 오타인데도 통과 (name이어야 했을 수도)
};
```

### (2) “필수 키”를 강제할 수 없음

```ts
type Rocket = { [k: string]: string };

const r: Rocket = {}; // ❌ 아무 키도 없어도 통과
```

### (3) 키마다 다른 값 타입을 표현하기 어려움

```ts
type Rocket = { [k: string]: string };

// thrust는 number여야 하는데 string으로 고정돼 버림
```

### (4) 언어 서비스(자동완성/리네임/점프)가 약해짐

키가 “뭐든 가능”이면 IDE가 추천/추론을 잘 못 합니다.

---

## 3. 결론: 키를 알고 있다면 인덱스 시그니처 말고 인터페이스

키가 정해져 있다면 가장 좋은 건 **명시적 필드**입니다.

```ts
interface Rocket {
  name: string;
  variant: string;
  thrust_kN: number;
}

const falconHeavy: Rocket = {
  name: "Falcon Heavy",
  variant: "v1",
  thrust_kN: 15_200,
};
```

✅ interface 장점

- 필수 필드 강제
- 오타 방지
- 키별 타입 분리 가능
- 자동완성/정의로 이동/이름 바꾸기 등 언어 서비스가 최대치로 동작

> **결론:** _키를 미리 알 수 없는 “진짜 동적 데이터”에서만_ 인덱스 시그니처를 쓰고, 가능하면 **더 정확한 타입(인터페이스/Record/매핑된 타입/Map)** 으로 모델링하자.

<br/>
<br/>

# 아이템 16: number 인덱스 시그니처보다 Array, 튜플, ArrayLike를 사용하기

## 1. 자바스크립트 객체와 키의 문제

- 숫자를 키로 써도 → **문자열로 변환**
- 배열 역시 객체이기 때문에 문자열 키 접근이 가능

👉 이게 **혼란의 시작점**

---

## 2. 타입스크립트는 그 혼란을 타입으로 정리하려고 `number` 인덱스를 따로 취급

- 배열 인덱싱을 number 로만 허용하는 타입 규칙 도입:

```ts
interface Array<T> {
  [n: number]: T;
}
```

---

## 3. number 인덱스 시그니처의 문제점

### ❌ 문자열 인덱싱이 타입을 망가뜨림

```ts
const xs = [1, 2, 3];

const a = xs[0]; // number
const b = xs["1"]; // ❌ 암묵적 any
```

```ts
function get<T>(array: T[], k: string): T {
  return array[k]; // ❌ 인덱스가 number가 아님
}
```

- 타입 시스템이 깨짐
- 암묵적 `any` 발생
- IDE 추론/자동완성 품질 저하

---

## 4. 최종 결론: number 인덱스 시그니처보다 Array, 튜플, ArrayLike를 사용하기

길이와 숫자 접근만 필요할 때:

```ts
function checkedAccess<T>(xs: ArrayLike<T>, i: number): T {
  if (i < xs.length) {
    return xs[i];
  }
  throw new Error("범위를 벗어남");
}
```

```ts
const tupleLike: ArrayLike<string> = {
  0: "A",
  1: "B",
  length: 2,
}; // ✅ 정상
```

<br/>
<br/>

# 아이템 17: 변경 관련된 오류 방지를 위해 `readonly` 사용하기

## 1. 문제 상황 (1) : 변경이 숨어 있는 함수

## 2. 문제 상황 (2) : 버그의 핵심: 배열을 파괴하는 함수

```ts
function arraySum(arr: number[]) {
  let sum = 0,
    num;
  while ((num = arr.pop()) !== undefined) {
    sum += num;
  }
  return sum;
}
```

- `pop()`은 배열을 **직접 수정**
- 계산이 끝나면 `arr`은 빈 배열
- 호출자는 이를 전혀 알 수 없음 ❌

---

## 3. 해결책: `readonly`로 의도 명시하기

```ts
function arraySum(arr: readonly number[]) {
  let sum = 0,
    num;
  while ((num = arr.pop()) !== undefined) {
    // ❌ 컴파일 에러: readonly에는 pop이 없음
    sum += num;
  }
  return sum;
}
```

✅ 효과

- 배열 변경 시 **즉시 컴파일 에러**
- 함수의 의도가 명확해짐 (“읽기 전용”)

---

## 4. 매개변수에 `readonly`를 쓰면 생기는 일

- 타입스크립트가 **함수 내부 변경을 검사**
- 호출자는 “이 함수는 인자를 안 바꾼다”는 보장을 얻음
- readonly 배열도 인자로 전달 가능

👉 **인터페이스 계약(contract)** 이 명확해짐

---

## 🔍 readonly는 얕게(shallow) 동작

```ts
const dates: readonly Date[] = [new Date()];

dates.push(new Date()); // ❌
dates[0].setFullYear(2037); // ✅
```

---

## 5. `const` 와 `readonly` 의 차이점

### (1) const 는 '변수 재할당' 을 막고, readonly 는 '값(구조)의 변경'을 타입 레벨에서 막는다

```ts
function arraySum(arr: readonly number[]) {
  let sum = 0;
  for (const num of arr) {
    sum += num;
  }
  return sum;
} yRange: [number, number];
  color: string;

  onClick: (x: number, y: number, index: number) => void;
}
```

> `const`는 변수 **재할당만 금지**하고, `readonly number[]`는 **타입 레벨에서 내부 변경(pop, push 등)을 금지**한다.

---

### (2) const 와 readonly 차이점 핵심

> **const는 runtime, readonly는 type-level이다**


---

### 한 문장으로 끝내기

> **const는 변수 보호, readonly는 데이터 보호다.**

<br/>
<br/>

# 아이템 18: 매핑된 타입을 사용하여 값을 동기화하기

## 1. 문제 배경: Scatter 차트 최적화

산점도(scatter plot) UI 컴포넌트의 props 예시:

```ts
interface ScatterProps {
  xs: number[];
  ys: number[];

  xRange: [number, number];
  yRange: [number, number];
  color: string;

  onClick: (x: number, y: number, index: number) => void;
}
```

렌더링 최적화를 위해  
“**어떤 props가 바뀌었을 때 다시 그릴지**”를 판단해야 한다.

---

## 2. 안 좋은 접근 1: 조건 나열 (fail-open)

```ts
function shouldUpdate(oldProps: ScatterProps, newProps: ScatterProps) {
  return (
    oldProps.xs !== newProps.xs ||
    oldProps.ys !== newProps.ys ||
    oldProps.xRange !== newProps.xRange ||
    oldProps.yRange !== newProps.yRange ||
    oldProps.color !== newProps.color
  );
}
```

❌ 새 prop 추가 시 빠뜨려도 타입 에러가 나지 않음

---

## 3. 안 좋은 접근 2: 반복 + 예외 처리 (fail-close)

```ts
function shouldUpdate(oldProps: ScatterProps, newProps: ScatterProps) {
  let k: keyof ScatterProps;
  for (k in oldProps) {
    if (oldProps[k] !== newProps[k]) {
      if (k !== "onClick") return true;
    }
  }
  return false;
}
```

❌ 비교 규칙이 코드 안에 흩어짐  
❌ 유지보수 어려움

---

## 4. 핵심 해법: 매핑된 타입으로 규칙 고정

```ts
const REQUIRES_UPDATE: { [K in keyof ScatterProps]: boolean } = {
  xs: true,
  ys: true,
  xRange: true,
  yRange: true,
  color: true,
  onClick: false,
};
```

- `ScatterProps`의 키와 **100% 동기화**
- 키 추가/삭제 시 즉시 컴파일 에러

---

## 5. 핵심은 매핑된 타입과 객체를 사용하는 것: 왜 배열이 아니라 객체인가?

- 모든 키가 고려됐는지 보장 불가 ❌
- boolean 맵 + 매핑된 타입만이 완전한 해결책
